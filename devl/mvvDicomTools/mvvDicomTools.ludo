import "core"

//
// TODO: handle DYNAMIC and GATED for DICOM volume loading
//

/**
 DICOM manipulation wrapper using DCMTK (see http://dicom.offis.de/) as back end
 */

/**
 @brief DICOM common attributs for Volume/Slice description
 */
class DicomAttributs
{
   // 1 - [0010-0010] Patient name
   string patientName;

   // 2 - [ 0010-4000 ] Patient ID
   string patientID;

   // 3 - [ 0010-0040 ] Patient Sex
   string patientSex;

   // 4 - [ 0010-1010 ] Patient Age
   float patientAge;

   // 5 - [ 0010-1030 ] Patient Weight
   float patientWeight;

   // 6 - [ 0008-0020 ] Study date
   string studyDate;

   // 7 - [ 0008-0030 ] Study Time
   string studyTime;

   // 8 - [ 0008-1030 ] Study description
   string studyDescription;

   // 9 - [ 0020-0010 ] Study ID
   string studyID;

   // 10 - [ 0008-0021 ] Series Date
   string seriesDate;

   // 11 - [ 0008-0031 ] Series Time
   string seriesTime;

   // 12 - [ 0008-103E ] Series Description
   string seriesDescription;

   // 13 - [ 0008-0022 ] Acquisition Date
   string acquisitionDate;

   // 14 - [ 0008-0032 ] Acquisition Time
   string acquisitionTime;

   // 15 - [ 0008-0070 ] Modality
   string modality;

   // 16 - [ 0020-000D ] Study Instance UID
   string studyInstanceUid;

   // 17 - [ 0020-000E ] Series Instance UID
   string seriesInstanceUid;

   // 18 - [ 0020-0032 ] Image Position Patient
   Vector3f imagePositionPatient;

   // 19 - [ 0028-0010 ] Rows
   int rows;

   // 20 - [ 0028-0011 ] Columns
   int columns;

   // 21 - [ 0028-0030 ] pixel spacing
   Vector2f pixelSpacing;

   // 22 - [ 0020-0013 ] Instance number
   int instanceNumber;
   
   // 23 - [ 0028-1053] Rescale slope
   float slope;
   
   // 24 - [ 0028-1052] Rescale Intercept
   float intercept;
   
   // 25 - [ 0020-0052 ] Frame of Reference UID
   string frameOfReference;
   
   // 26 - not a DICOM tag, this will be used in the following cases:
   // - exporting a Volume as a DICOM file
   float extraSliceSpacing;

   // 27 - [ 0020-0037 ] Image Orientation Patient, axis X
   Vector3f imageOrientationPatientX;

   // 28 - [ 0020-0037 ] Image Orientation Patient, axis Y
   Vector3f imageOrientationPatientY;

   // 29 - [ 0008-0018 ] SOP Instance IUD
   string sopInstanceUid;
   
   DicomAttributs()
   {
      instanceNumber = -1;
	   extraSliceSpacing = 0.0;
	   imagePositionPatient = Vector3f( 0.0, 0.0, 0.0 );
      imageOrientationPatientX = Vector3f( 1.0, 0.0, 0.0 );
      imageOrientationPatientY = Vector3f( 0.0, 1.0, 0.0 );
   }
}

/**
 @brief Read a volume from a DICOM directory. The first volume read is returned
 @param attributs if an attribut is not NULL, it will be populated with the corresponding values
 */
import VolumeID readDicomVolume( string directory, DicomAttributs attributs = NULL );

/**
 @brief Read the volumes contained in a DICOM directory
 @param attributs if an attribut is not NULL, it will be populated with the corresponding values
 @param studyIndex index on the volumes belonging to the same Study
        e.g. studyIndex = [ 3, 6 ], with 10 series,
        means the volume 0-3 => study 0
                  volume 4-6 => study 1
                  volume 7-9 => study 2
 @note when loaded, it is guaranteed volumes belonging to the same study UID will be consecutive
 */
import VolumeID[] readDicomVolumes( string directory, DicomAttributs[] attributs = NULL, int[] studyIndex = NULL );

/**
 @brief returns the size of the array
 */
import int size( DicomSlice[] array );

/**
 @brief Write a DICOM volume, if the <attributs> is not NULL, its header will be used to write the DICOM files

 TODO IMPLEMENT
 */
//import void writeDicomVolume( VolumeID volume, string outputDirectory, DicomAttributs attributs = NULL );

/**
 @brief Hold a DICOM slice

 Internally the DICOM file is stored but not accessible except form the <mainAttributs> that will be synced
 for I/O
 */
class DicomSlice
{
   DicomAttributs mainAttributs;

   // not constructible!
   import ~DicomSlice();

   /**
    @brief Set a tag (group, element) with a new value. If the tag is part of <DicomAttributs>,
           the attribut will be updated, if not the actual Dicom file held internally will be updated

    @note the string will be internally converted to any require VR, it can also be used with VM > 1
          by separating the values by the character '\'
          e.g. pixel spacing: setTag( 0x0028, 0x0030, "1.5" + "\\" + "1.6" )

          This may not work for some specific Tag. Only for Tag with VR = {AE, AS, CS, DA, DS, DT, IS, LO, LT, PN, SH, ST, TM, UI, UT}
          For example pixel data tag has VR VR_ox in DCMTK
    */
   import void setTag( int group, int element, string value );

   import string getTag( int group, int element );

   import void setPixelTag( string value );
   import string getPixelTag();
}

/**
 @brief Read a specific DICOM slice
 */
import DicomSlice readDicomSlice( string path );

/**
 @brief Read a specific DICOM directory and return all DICOM slices
 @note it is guaranteed to be sorted by Series Instance UID
 @param seriesIndex index on the slices belonging to the same series
        e.g. seriesIndex = [ 3, 6 ], with 10 slices,
        means the slice 0-3 => series 0
                  slice 4-6 => series 1
                  slice 7-9 => series 2
        if seriesIndex == NULL, the series will not be exported
 */
import DicomSlice[] readDicomSlices( string path, int[] seriesIndex = NULL );


/**
 @brief find the different studies.
 @param slices It is assuming the slices are grouped by series and studies (i.e., all studies are stored
        contiguously)
 @param studiesIndex
           e.g. studiesIndex = [ 3, 6 ], with 10 series,
           means the series 0-3 => study 0
                     series 4-6 => study 1
                     series 7-9 => study 2
 */
// int[] findDicomStudies( DicomSlice[] slices, int[] studiesIndex ); // TODO IMPLEMENT

/**
 @brief Function that will name a DICOM slice, this is used to personalize the how the slice are named
        It can be extended so that the functions give different directories to different series instance UID...
 */
typedef string ( DicomSlice slice )  DicomSliceNamingFunc;

string defaultDicomSliceNamingFunc( DicomSlice slice )
{
   return slice.mainAttributs.seriesInstanceUid + "-" + slice.mainAttributs.sopInstanceUid + ".dcm";
}

/**
 @brief Write a DICOM slice on the disk
 @note  Note that if the <mainAttributs> in <DicomSlice> have been modified
        they will be updated
 */
import void writeDicomSlice( DicomSlice slice, string path );

/**
 @brief Write DICOM slices on the disk
 @note  Note that if the <mainAttributs> in <DicomSlice> have been modified
        they will be updated
 */
import void writeDicomSlices( DicomSlice[] slices, string directory, DicomSliceNamingFunc namingSlice = defaultDicomSliceNamingFunc );