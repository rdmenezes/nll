include "core"

//
// TODO: handle DYNAMIC and GATED DICOM data
//

/**
 DICOM manipulation wrapper using DCMTK (see http://dicom.offis.de/) as back end
 */

/**
 @brief DICOM common attributs for Volume/Slice description
 */
class DicomAttributs
{
   // 1 - [0010-0010] Patient name
   string patientName;

   // 2 - [ 0010-4000 ] Patient ID
   string patientID;

   // 3 - [ 0010-0040 ] Patient Sex
   string patientSex;

   // 4 - [ 0010-1010 ] Patient Age
   float patientAge;

   // 5 - [ 0010-1030 ] Patient Weight
   float patientWeight;

   // 6 - [ 0008-0020 ] Study date
   string studyDate;

   // 7 - [ 0008-0030 ] Study Time
   string studyTime;

   // 8 - [ 0008-1030 ] Study description
   string studyDescription;

   // 9 - [ 0020-0010 ] Study ID
   string studyID;

   // 10 - [ 0008-0021 ] Series Date
   string seriesDate;

   // 11 - [ 0008-0031 ] Series Time
   string seriesTime;

   // 12 - [ 0008-103E ] Series Description
   string seriesDescription;

   // 13 - [ 0008-0022 ] Acquisition Date
   string acquisitionDate;

   // 14 - [ 0008-0032 ] Acquisition Time
   string acquisitionTime;

   // 15 - [ 0008-0070 ] Modality
   string modality;

   // 16 - [ 0020-000D ] Study Instance UID
   string studyInstanceUid;

   // 17 - [ 0020-000E ] Series Instance UID
   string seriesInstanceUid;

   // 18 - [ 0020-0032 ] Image Position Patient
   Vector3f imagePositionPatient;

   // 19 - [ 0028-0010 ] Rows
   int rows;

   // 20 - [ 0028-0011 ] Columns
   int columns;

   // 21 - [ 0028-0030 ] pixel spacing
   Vector2f pixelSpacing;

   // 22 - [ 0020-0013 ] Instance number
   int instanceNumber;
   
   // 23 - [ 0028-1053] Rescale slope
   float slope;
   
   // 24 - [ 0028-1052] Rescale Intercept
   float intercept;
   
   // 25 - [ 0020-0052 ] Frame of Reference UID
   string frameOfReference;
   
   // 26 - not a DICOM tag, this will be used in the following cases:
   // - exporting a Volume as a DICOM file
   float extraSliceSpacing;

   // 27 - [ 0020-0037 ] Image Orientation Patient, axis X
   Vector3f imageOrientationPatientX;

   // 28 - [ 0020-0037 ] Image Orientation Patient, axis Y
   Vector3f imageOrientationPatientY;

   // 29 - [ 0008-0018 ] SOP Instance IUD
   string sopInstanceUid;
   
   DicomAttributs()
   {
      instanceNumber = -1;
	   extraSliceSpacing = -1.0;
	   imagePositionPatient = Vector3f( -1.0, -1.0, -1.0 );
   }
}

/**
 @brief Read a volume from a DICOM directory. The first volume read is returned
 @param attributs if an attribut is not NULL, it will be populated with the corresponding values
 */
import VolumeID readDicomVolume( string directory, DicomAttributs attributs = NULL );

/**
 @brief Read the volumes contained in a DICOM directory
 @param attributs if an attribut is not NULL, it will be populated with the corresponding values
 @param studyIndex index on the volumes belonging to the same Study
        e.g. studyIndex = [ 3, 6 ], with 10 series,
        means the volume 0-3 => study 0
                  volume 4-6 => study 1
                  volume 7-9 => study 2
 @note when loaded, it is guaranteed volumes belonging to the same study UID will be consecutive
 */
import VolumeID[] readDicomVolumes( string directory, DicomAttributs[] attributs = NULL, int[] studyIndex = NULL );

/**
 @brief returns the size of the array
 */
import int size( VolumeID[] array );
import int size( int[] array );
import int size( DicomSlice[] array );

/**
 @brief Write a DICOM volume, if the <attributs> is not NULL, its header will be used to write the DICOM files
 */
import void writeDicomVolume( VolumeID volume, string outputDirectory, DicomAttributs attributs = NULL );

/**
 @brief Hold a DICOM slice

 Internally the DICOM file is stored but not accessible except form the <mainAttributs> that will be synced
 for I/O
 */
class DicomSlice
{
   DicomAttributs mainAttributs;

   // not constructible!
   import ~DicomSlice();
}

/**
 @brief Read a specific DICOM slice
 */
import DicomSlice readDicomSlice( string path );

/**
 @brief Read a specific DICOM directory and return all DICOM slices
 @note it is guaranteed to be sorted by Series Instance UID
 */
import DicomSlice[] readDicomSlices( string path );

/**
 @brief Function that will name a DICOM slice, this is used to personalize the how the slice are named
        It can be extended so that the functions give different directories to different series instance UID...
 */
typedef string ( DicomSlice slice )  DicomSliceNamingFunc;

string defaultDicomSliceNamingFunc( DicomSlice slice )
{
   return slice.mainAttributs.seriesInstanceUid + "-" + slice.mainAttributs.sopInstanceUid + ".dcm";
}

/**
 @brief Write a DICOM slice on the disk
 @note  Note that if the <mainAttributs> in <DicomSlice> have been modified
        they will be updated
 */
import void writeDicomSlice( DicomSlice slice, string path );

/**
 @brief Write DICOM slices on the disk
 @note  Note that if the <mainAttributs> in <DicomSlice> have been modified
        they will be updated
 */
import void writeDicomSlices( DicomSlice[] slices, string directory, DicomSliceNamingFunc namingSlice = defaultDicomSliceNamingFunc );

/**
 @brief Defines a soring operation, if lhs < rhs, returns -1, else if lhs > rhs return 1, else return 0
 */
typedef int ( DicomSlice lhs, DicomSlice rhs )  DicomComparisonFunc;

/**
 @brief Sort a set of slices according to a sort operation
 */
import void sortSlice( DicomSlice[] slices, DicomComparisonFunc sorter );

/**
 @brief Efficient sorter for the most common sorting operation.
 
 Sort the slice by study ID, within study ID, sort by series ID and finally within series ID sort by position
 */
import void sortSliceByPosition( DicomSlice[] slices );