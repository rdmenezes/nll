import "core"
import "siemens"
import "mvvDicomTools"

include "helper1"

/**
 @note the following variables must have been defined:
       - "layout" of type "Layout" defines the layout and event dispatcher to be used.
       - "callbacks" of type "KeyboardCallback" defines the scripts to be called upon the specific key pressed.

 @note the following variables may be defined (if not default values apply)
       - "sizeHistoryExport" of type "int", defines the number of commands imported/exported between sessions
       - "historyExportLocation" of type "string", defines where the command history is imported/exported
 */

//
// configuration constants
// -----------------------------------------------------------------------------------------------------------------
//

/// saves the last XXX commands typed by the user, these will be imported next sessions
int      sizeHistoryExport            = 500;

/// defines the export/import location
string   historyExportLocation        = "c:/Temp/command_history.txt";

//
// -----------------------------------------------------------------------------------------------------------------

SegmentToolCentering    toolCentering;
MipToolPointer          toolPointerMip(17);
ToolAnnotations         annotations;
ToolManipulators        manipultors;
ManipulatorPointer      pointer;

VolumeContainer         volumes;


class VolumeSwitchReg
{
   int index                        = 0;
   Lut lut1                         = NULL;
   Lut lut2                         = NULL;
   Lut lut3                         = NULL;
   VolumeID displayed1              = NULL;
   VolumeID displayed2              = NULL;
   DisplayRegionDetection detection = NULL;
   VolumeContainer volumes          = NULL;
   RegistrationMr registrator		   = NULL;
   int groundtruth	= 0; 
   ImageHolder holderx = NULL;
   ImageHolder holdery = NULL;
   ImageHolder holderz = NULL;
   ToolAnnotations annotations = NULL;

   AffineRegistration tfmGroundTruth;
   AffineRegistration tfmReg;

   VolumeSwitchReg( Lut l1, Lut l2, Lut l3, VolumeContainer vs, RegistrationMr reg, ImageHolder hx, ImageHolder hy, ImageHolder hz, ToolAnnotations toolAnnotations )
   {
      lut1 = l1;
      lut2 = l2;
	  lut3 = l3;
      volumes = vs;
	  registrator = reg;

	  holderx = hx;
	  holdery = hy;
	  holderz = hz;

	  annotations = toolAnnotations;

      //displayed1 = readDicomVolume( list[ 6 ] );
   }

   void next()
   {
      index = index + 1;
	  register();
   }

   void switchGroundTruth()
   {
      volumes.clear();
      groundtruth = 1 - groundtruth;
	  if ( groundtruth == 1 )
	  {
	     print( "GROUND TRUTH" );
		 volumes.add( displayed2, lut1, 1.0, tfmGroundTruth );
	  } else {
	     print( "ALGO RESULT" );
	     volumes.add( displayed2, lut1, 1.0, tfmReg );
	  }
      volumes.add( displayed1, lut2, 1.0 );
   }

   void register()
   {
      annotations.clear();
	  volumes.clear();
	  groundtruth = 0;

	  //string name = registrator.getTestMrVolume( index );
	  string name = registrator.getTestPtVolume( index );
	  //name = "PT-390";  // atrophy
	  //name = "PT-394";
	  //name = "PT-398";
	  //name = "PT-399";
	  //name = "PT-405";
	  //name = "PT-411";
	  //name = "PT-412";
	  //name = "PT-413";
	  //name = "PT-435";
	  //name = "PT-449";
	  //name = "PT-501";
	  //name = "PT-508";
	  //name = "PT-509";

	  //name = "PT-382";	// atrophy

	  //name = "PT-506";	// atrophy lateral
	  //name = "PT-492";	// atrophy lateral

	  //name = "PT-86";

      //string base = "D:/devel/sandbox_vs2010/RegistrationImpl/data/mr/";
	  string base = "D:/devel/sandbox_vs2010/RegistrationImpl/data/pt/";
      string volname = base + name;


      print( "----------------=" + volname );
      displayed2 = readDicomVolume( volname );
	  Volume v = displayed2.getVolume();

      lut1.detectRange( displayed2, 0.8 );
	  //lut1.setVolcanoColor(Vector3i(0, 255, 0), 3.0, 0.6);
	  //lut1.set( 1.01, 5.05, Vector3i( 255, 0, 0 ) );
      
	  int id = 1;
	  AffineRegistration tfm;

	  //-> recompute reg
      tfmReg = registrator.affinePlanarRegistrationPt( displayed2, id );
	  //-> OR get the result
	  //Matrix4f t = registrator.getRegistrationPrecomputed( "template_PT", name ); tfmReg = AffineRegistration( t );
	  //-> END

	  tfmGroundTruth = AffineRegistration( registrator.getGoundTruth( "template_PT", name ) );
	  displayed1 = registrator.templates[0];
	  VolumeID displayed1mask = registrator.templates[1];
	  VolumeID displayed1roi = registrator.templates[2];

	  holderx.set(registrator.getDebugX());
	  holdery.set(registrator.getDebugY());
	  holderz.set(registrator.getDebugZ());

	  //volumes.add( displayed2, lut1, 1.0 );
      volumes.add( displayed2, lut1, 1.0, tfmReg );
      volumes.add( displayed1, lut2, 0.2 );
	  volumes.add( displayed1mask, lut3, 0.6 );
	  volumes.add( displayed1roi, lut3, 0.25 );
	  
	  print("TEMPLATE=");
	  print(registrator.templates[id]);

	  // transform to new space the barycenter
	  Lut lutCentre( 0.0, 50.0, Vector3i( 255, 255, 255 ) );
	  Vector3f center = barycentre( displayed2, lutCentre );
	  Vector3f centerTfm = tfmReg.transformInverse( center );
	  annotations.add( centerTfm, "" );
   }
}

class InsentisySwitchReg
{
   float LUT_MIN_TARGET = 0.0;
   float LUT_MAX_TARGET = 2000.0;
   float LUT_MIN_TEMPLATE = 32000.0;
   float LUT_MAX_TEMPLATE = 55000.0;

   int state = 1;
   VolumeSwitchReg switch = NULL;
   InsentisySwitchReg( VolumeSwitchReg sw )
   {
      switch = sw;
   }

   void run()
   {
      //VolumeContainer& volumes = switch.volumes;
      if ( state == 0 )
      {
		//switch.lut1.set( LUT_MIN_TARGET, LUT_MAX_TARGET, Vector3i(100));
		//switch.lut2.set( LUT_MIN_TEMPLATE, LUT_MAX_TEMPLATE, Vector3i(255, 255, 255));
		//switch.volumes.setIntensity( switch.displayed1, 0.5 );
        //switch.volumes.setIntensity( switch.displayed2, 1.0 );
	  
         switch.volumes.setIntensity( switch.displayed2, 1.0 );
         switch.volumes.setIntensity( switch.displayed1, 0.3 );
         //switch.volumes.setLut( switch.displayed1, switch.lut2 );
         //switch.volumes.setLut( switch.displayed2, switch.lut1 );
		 
      } else {
	    //switch.lut1.set( LUT_MIN_TARGET, LUT_MAX_TARGET, Vector3i(255, 255, 255));
		//switch.lut2.set( LUT_MIN_TEMPLATE, LUT_MAX_TEMPLATE, Vector3i(100));
		//switch.volumes.setIntensity( switch.displayed2, 0.5 );
        //switch.volumes.setIntensity( switch.displayed1, 1.0 );
	  
         switch.volumes.setIntensity( switch.displayed1, 1.0 );
         switch.volumes.setIntensity( switch.displayed2, 0.3 );
         //switch.volumes.setLut( switch.displayed1, switch.lut1 );
         //switch.volumes.setLut( switch.displayed2, switch.lut2 );
      }
      state = 1 - state;
   }
}

class LutSwitchReg
{
   int state = 1;
   VolumeSwitchReg switch = NULL;
   LutSwitchReg( VolumeSwitchReg sw )
   {
      switch = sw;
   }

   void run()
   {
      //VolumeContainer& volumes = switch.volumes;
      if ( state == 0 )
      {
         switch.volumes.setLut( switch.displayed1, switch.lut2 );
         switch.volumes.setLut( switch.displayed2, switch.lut1 );
      } else {
         switch.volumes.setLut( switch.displayed1, switch.lut1 );
         switch.volumes.setLut( switch.displayed2, switch.lut2 );
      }
      state = 1 - state;
   }
}



Lut ctLut1( 0.0, 500.0, Vector3i( 255, 255, 255 ) );
Lut ctLut2( 32000.0, 55000.0, Vector3i( 0, 255, 0 ) );
ctLut2.setVolcanoColor(Vector3i(0, 255, 0), 3.0, 0.4);
Lut ctLut3( 0.0, 1.0, Vector3i( 255, 0, 0 ) );

RegistrationMr registrator( "c:/tmp/templates.bin",
                            "c:/tmp/templatesPt.bin"  );

KeyboardCallback callbacks;

ImageHolder holderx;
ImageHolder holdery;
ImageHolder holderz;

VolumeSwitchReg switch( ctLut1, ctLut2, ctLut3, volumes, registrator, holderx, holdery, holderz, annotations );
callbacks.addShortcut( switch.next, "F3" );


InsentisySwitchReg switchIntensity( switch );
callbacks.addShortcut( switchIntensity.run, "F1" );
/*
LutSwitchReg switchLut( switch );
callbacks.addShortcut( switchLut.run, "F2" );
*/
callbacks.addShortcut( switch.switchGroundTruth, "F2" );


ManipulatorPoint manipulator1( Vector3f(0.0, 0.0, 0.0) );
manipultors.add( pointer );

float factor = 1.5;
Segment segment1( volumes, Vector3f( factor, 0.0, 0.0 ), Vector3f( 0.0, -factor, 0.0 ) );
segment1.setTool( toolCentering );
segment1.setTool( manipultors );
segment1.setTool( annotations );
//segment1.setInterpolator( typename Segment::Nearest() );

Segment segment2( volumes, Vector3f( 0.0, factor, 0.0 ), Vector3f( 0.0, 0.0, factor ) );
segment2.setTool( toolCentering );
segment2.setTool( manipultors );
segment2.setTool( annotations );
//segment2.setInterpolator( typename Segment::Nearest() );

Segment segment3( volumes, Vector3f( factor, 0.0, 0.0 ), Vector3f( 0.0, 0.0, factor ) );
segment3.setTool( toolCentering );
segment3.setTool( manipultors );
segment3.setTool( annotations );
//segment3.setInterpolator( typename Segment::Nearest() );


Layout::Vertical vertical;
Layout::Horizontal horizontal;
Layout l1( segment1 );
Layout l2( segment2 );
Layout l3( segment3 );
Layout l6( Console() );


Layout imx( holderx );
Layout imy( holdery );
Layout imz( holderz );

Layout layoutDisplay1( horizontal, Layout(horizontal, l1, l2, 0.51), l3, 0.66 );
Layout layoutDisplay2( horizontal, Layout(horizontal, imx, imy, 0.51), imz, 0.66 );


//Layout layout = Layout(vertical, l6, Layout(vertical, layoutDisplay1, layoutDisplay2, 0.79), 0.05);
Layout layout = layoutDisplay1;

ImageHolder holder;
Layout layout1 = layout;
Layout layout2 = Layout(vertical, Layout(Console()), Layout(holder), 0.5);



// start directly...
switch.next();