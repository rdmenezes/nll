// list of local volumes to analyse...
string volumeList[] =
{
   "D:/Devel/sandbox/regionDetectionTest/data/case300.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case301.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case302.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case303.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case304.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case305.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case306.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case307.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case308.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case309.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case310.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case311.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case312.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case313.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case314.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case315.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case316.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case317.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case318.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case400.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case401.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case402.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case403.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case404.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case405.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case406.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case407.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case408.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case409.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case410.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case411.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case412.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case413.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case414.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case500.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case501.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case502.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case503.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case504.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case505.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case506.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case507.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case48.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case49.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case50.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case51.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case52.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case53.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case54.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case55.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case56.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case57.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case58.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case59.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case60.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case61.mf2",
   "D:/Devel/sandbox/regionDetectionTest/data/case62.mf2"
};

/**
 @brief Pre-load volumes to speed up loading time
 */
class VolumeSwitch
{
   int index                        = 0;
   Lut lut                          = NULL;
   VolumeID displayed               = NULL;
   VolumeID preloaded               = NULL;
   DisplayRegionDetection detection = NULL;
   VolumeContainer volumes          = NULL;
   string[] list;

   VolumeSwitch( Lut l, VolumeContainer vs, string[] volumeList, DisplayRegionDetection rd )
   {
      lut = l;
      volumes = vs;
      list = volumeList;
      detection = rd;

      preloaded = readVolumeMF2Asynchronous( list[ index ] );
   }

   void next()
   {
      volumes.clear();
      displayed = preloaded;
      volumes.add( displayed, lut );
      detection.annotations.clear();
      Vector3f b = barycentre( displayed, lut );
      detection.compute( displayed );
      detection.annotations.add( b, "barycentre" );

      index = index + 1;
      preloaded = readVolumeMF2Asynchronous( list[ index ] );
      print("pre-load volume:" + list[ index ] );
   }
}

/**
 @brief Create an annotation where the pointer is located
 */
class AnnotationCreator
{
   ToolAnnotations      annotations;
   ManipulatorPointer   pointer;
   int                  id;

   AnnotationCreator( ToolAnnotations a, ManipulatorPointer p )
   {
      annotations = a;
      pointer = p;
      id = 1;
   }

   void run()
   {
      annotations.add( pointer.getPosition(), toString( id ) );
      id = id + 1;
   }
}

/**
 @brief find the maximum intensity voxel within a radius from the pointer
 */
class FindPeakVoxel
{
   VolumeID volume = NULL;
   int range;
   ManipulatorPointer pointer = NULL;
   
   FindPeakVoxel( VolumeID v, int rangeInVoxel, ManipulatorPointer p )
   {
      volume = v;
      range = rangeInVoxel;
      pointer = p;
   }
   
   void run()
   {
      Volume v = getVolume( volume );
      Vector3f posInVoxel = v.positionToIndex( pointer.getPosition() );
      posInVoxel = Vector3f( toFloat( round( posInVoxel[ 0 ] ) ),
                             toFloat( round( posInVoxel[ 1 ] ) ),
                             toFloat( round( posInVoxel[ 2 ] ) ) );
      if ( posInVoxel[ 0 ] < 0.0 ||
           posInVoxel[ 1 ] < 0.0 ||
           posInVoxel[ 2 ] < 0.0 ||
           posInVoxel[ 0 ] >= v.getSize()[ 0 ] ||
           posInVoxel[ 1 ] >= v.getSize()[ 1 ] ||
           posInVoxel[ 2 ] >= v.getSize()[ 2 ] )
      {
        return;
      }
      
      float minx = max( 0.0, posInVoxel[ 0 ] - range );
      float miny = max( 0.0, posInVoxel[ 1 ] - range );
      float minz = max( 0.0, posInVoxel[ 2 ] - range );
      
      float maxx = min( posInVoxel[ 0 ] + range, toFloat( v.getSize()[ 0 ] ) );
      float maxy = min( posInVoxel[ 1 ] + range, toFloat( v.getSize()[ 1 ] ) );
      float maxz = min( posInVoxel[ 2 ] + range, toFloat( v.getSize()[ 2 ] ) );
      
      float max = -99999.0;
      Vector3f pos;
      
      float z = minz;
      while ( z <  maxz )
      {
        float y = miny;
        while ( y <  maxy )
        {
          float x = minx;
          while ( x <  maxx )
          {
            Vector3f posCur( x, y, z );
            float value = v.getValue( posCur );
            if ( value > max )
            {
              max = value;
              pos = posCur;
            }
            x = x + 1;
          }
          y = y + 1;
        }
        z = z + 1;
      }
      
      print(pos);
      pointer.setPosition( v.indexToPosition( pos ) );
   }
}

/**
 @brief Helper object creating interactively a cuboid object that can be retrieved...
 */
class CuboidCreator
{
   Vector2i mouseLastPos;
   ManipulatorCuboid cuboid = NULL;
   ToolManipulators  manipulators = NULL;

   CuboidCreator( ToolManipulators  m )
   {
      assert( m != NULL, "ToolManipulators cannot be null!" );
      manipulators = m;
   }

   void start()
   {
      setOnSegmentLeftMousePressed( this.cuboidCreate );
   }

   void cuboidCreate(Vector2i mousePosition, Vector3f segmentOrigin, Vector2f segmentSpacing, Vector2i segmentSize, Vector3f axisx, Vector3f axisy )
   {
      Vector2i dm = mousePosition;
      Vector3f d( toFloat( dm[ 0 ] ) * axisx[ 0 ] * segmentSpacing[ 0 ] + toFloat( dm[ 1 ] ) * axisy[ 0 ] * segmentSpacing[ 1 ],
                  toFloat( dm[ 0 ] ) * axisx[ 1 ] * segmentSpacing[ 0 ] + toFloat( dm[ 1 ] ) * axisy[ 1 ] * segmentSpacing[ 1 ],
                  toFloat( dm[ 0 ] ) * axisx[ 2 ] * segmentSpacing[ 0 ] + toFloat( dm[ 1 ] ) * axisy[ 2 ] * segmentSpacing[ 1 ] );

      if ( cuboid != NULL )
      {
         cuboid.setP1( segmentOrigin + d );
         cuboid.setP2( segmentOrigin + d );
      } else {
         cuboid = ManipulatorCuboid( segmentOrigin + d, segmentOrigin + d );
      }
      manipulators.add( cuboid );

      setMousePointer( 5 );
      setOnSegmentLeftMousePressed( this.cuboidUpdate );
      setOnSegmentLeftMouseRelease( this.cuboidEnd );
      mouseLastPos = mousePosition;
   }

   void cuboidUpdate(Vector2i mousePosition, Vector3f segmentOrigin, Vector2f segmentSpacing, Vector2i segmentSize, Vector3f axisx, Vector3f axisy )
   {
      Vector2i dm = mousePosition - mouseLastPos;
      mouseLastPos = mousePosition;

      Vector3f d( toFloat( dm[ 0 ] ) * axisx[ 0 ] * segmentSpacing[ 0 ] + toFloat( dm[ 1 ] ) * axisy[ 0 ] * segmentSpacing[ 1 ],
                  toFloat( dm[ 0 ] ) * axisx[ 1 ] * segmentSpacing[ 0 ] + toFloat( dm[ 1 ] ) * axisy[ 1 ] * segmentSpacing[ 1 ],
                  toFloat( dm[ 0 ] ) * axisx[ 2 ] * segmentSpacing[ 0 ] + toFloat( dm[ 1 ] ) * axisy[ 2 ] * segmentSpacing[ 1 ] );
      cuboid.setP2( cuboid.getP2() + d );
     // manipulators.notify();
   }

   void cuboidEnd(Vector2i mousePosition, Vector3f segmentOrigin, Vector2f segmentSpacing, Vector2i segmentSize, Vector3f axisx, Vector3f axisy )
   {
      // restore the settings
      setMousePointer( 1 );
      setOnSegmentLeftMousePressed( NULL );
      setOnSegmentLeftMouseRelease( NULL );
   }
}

/**
 @brief simple Callbacks object. It basically associates a keyboard's key to a call back to be executed
        everytime this key is pressed
 @note to add a shortcut, you need to update the full KeyboardCallback object and not only the arrays
       as the application is watching for the object's addresse change and not its content
 */
class KeyboardCallback
{
   typedef void() KeyCallback;

   KeyCallback[]  callbacks;                 // hold a call back
   string[]       callbacksKey;              // hold the key for the corresponding callback
   int[]          callbacksKeyModifier;      // corresponding modifier for the key: (0 => normal), (1 => CTRL), (2 => SHIFT), (3 => ALT)
   int            nbCallBacks = 0;           // the number of callbacks stored

   void addShortcut( KeyCallback callback, string key, int modifier = 0 )
   {
      print("nbCallbacks=" + toString(nbCallBacks));
      KeyCallback c  [ nbCallBacks + 1 ];
      string      ck [ nbCallBacks + 1 ];
      int         ckm[ nbCallBacks + 1 ];

      // copy over the data in a new array
      int n = 0;
      while ( n < nbCallBacks )
      {
         c  [ n ] = callbacks[ n ];
         ck [ n ] = callbacksKey[ n ];
         ckm[ n ] = callbacksKeyModifier[ n ];
         n = n + 1;
      }

      // add the new shortcut
      c  [ nbCallBacks ] = callback;
      ck [ nbCallBacks ] = key;
      ckm[ nbCallBacks ] = modifier;

      KeyboardCallback o;
      o.callbacks = c;
      o.callbacksKey = ck;
      o.callbacksKeyModifier = ckm;
      o.nbCallBacks = nbCallBacks + 1;

      // replace the object
      this = o;
   }

   KeyboardCallback()
   {}
}
