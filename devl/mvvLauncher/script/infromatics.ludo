import "core"
import "siemens"

include "helper1"

/**
 @note the following variables must have been defined:
       - "layout" of type "Layout" defines the layout and event dispatcher to be used.
       - "callbacks" of type "KeyboardCallback" defines the scripts to be called upon the specific key pressed.

 @note the following variables may be defined (if not default values apply)
       - "sizeHistoryExport" of type "int", defines the number of commands imported/exported between sessions
       - "historyExportLocation" of type "string", defines where the command history is imported/exported
 */

//
// configuration constants
// -----------------------------------------------------------------------------------------------------------------
//

/// saves the last XXX commands typed by the user, these will be imported next sessions
int      sizeHistoryExport            = 500;

/// defines the export/import location
string   historyExportLocation        = "c:/Temp/command_history.txt";

//
// -----------------------------------------------------------------------------------------------------------------
//

SegmentToolCentering    toolCentering;
MipToolPointer          toolPointerMip(17);
ToolAnnotations         annotations;
ToolManipulators        manipultors;
ManipulatorPointer pointer;

VolumeContainer         volumes;

VolumeID pet = readVolumeMF2Asynchronous("../../nllTest/data/medical/pet.mf2");

Lut petLut( 5000.0, 20000.0, Vector3i( 0, 255, 0 ) );


class PostProcessing
{
   string text;
   
   PostProcessing( string s )
   {
      text = s;
   }
   
   void run( Image image, Vector2f spacing, Vector3f origin, Vector3f axisx, Vector3f axisy )
   {
      drawText( image,
                text,
                Vector2i( 0, image.sizey() - 16 ),
                15,
                Vector3i( 255, 0, 0 ) );
   }
}

PostProcessing postProcessing1( "ResultQuery1:" );
PostProcessing postProcessing2( "ResultQuery2:" );
PostProcessing postProcessing3( "ResultQuery3:" );


AffineRegistration petReg;
AffineRegistration ctReg;

volumes.add( pet, petLut, 0.5, petReg );

manipultors.add( pointer );

Segment segment1( volumes, Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, -1.0, 0.0 ) );
segment1.setTool( toolCentering );
segment1.setTool( manipultors );
segment1.setTool( annotations );

Segment segment2( volumes, Vector3f( 0.0, 1.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment2.setTool( toolCentering );
segment2.setTool( manipultors );
segment2.setTool( annotations );

Segment segment3( volumes, Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment3.setTool( toolCentering );
segment3.setTool( manipultors );
segment3.setTool( annotations );

VolumeContainer volumesResult[ 3 ];
ToolManipulators  manipulatorsResult[ 3 ];
ManipulatorPointer pointers[ 3 ];

Segment segment4a( volumesResult[ 0 ], Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, -1.0, 0.0 ) );
segment4a.setTool( manipulatorsResult[ 0 ] );
segment4a.setTool( ToolPostprocessing( postProcessing1.run ) );
Segment segment4b( volumesResult[ 0 ], Vector3f( 0.0, 1.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment4b.setTool( manipulatorsResult[ 0 ] );
Segment segment4c( volumesResult[ 0 ], Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment4c.setTool( manipulatorsResult[ 0 ] );

Segment segment5a( volumesResult[ 1 ], Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, -1.0, 0.0 ) );
segment5a.setTool( manipulatorsResult[ 1 ] );
segment5a.setTool( ToolPostprocessing( postProcessing2.run ) );
Segment segment5b( volumesResult[ 1 ], Vector3f( 0.0, 1.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment5b.setTool( manipulatorsResult[ 1 ] );
Segment segment5c( volumesResult[ 1 ], Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment5c.setTool( manipulatorsResult[ 1 ] );

Segment segment6a( volumesResult[ 2 ], Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, -1.0, 0.0 ) );
segment6a.setTool( manipulatorsResult[ 2 ] );
segment6a.setTool( ToolPostprocessing( postProcessing3.run ) );
Segment segment6b( volumesResult[ 2 ], Vector3f( 0.0, 1.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment6b.setTool( manipulatorsResult[ 2 ] );
Segment segment6c( volumesResult[ 2 ], Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment6c.setTool( manipulatorsResult[ 2 ] );

Segment resultSegments[] =
{
	segment4a, segment4b, segment4c,
	segment5a, segment5b, segment5c,
	segment6a, segment6b, segment6c
};

Layout::Vertical vertical;
Layout::Horizontal horizontal;
Layout l1( segment1 );
Layout l2( segment2 );
Layout l3( segment3 );
Layout l6( Console() );
Layout l4a( segment4a );
Layout l4b( segment4b );
Layout l4c( segment4c );

Layout l5a( segment5a );
Layout l5b( segment5b );
Layout l5c( segment5c );

Layout l6a( segment6a );
Layout l6b( segment6b );
Layout l6c( segment6c );

Layout result1 = Layout( horizontal, Layout(horizontal, l4a, l4b, 0.51), l4c, 0.66 );
Layout result2 = Layout( horizontal, Layout(horizontal, l5a, l5b, 0.51), l5c, 0.66 );
Layout result3 = Layout( horizontal, Layout(horizontal, l6a, l6b, 0.51), l6c, 0.66 );
Layout result = Layout( vertical, Layout(vertical, result3, result2, 0.51), result1, 0.66 );

Layout layoutDisplayMpr( horizontal, Layout(horizontal, l1, l2, 0.51), l3, 0.66 );
Layout layoutDisplay( vertical, result, layoutDisplayMpr, 0.51);
Layout layout = Layout(vertical, l6, layoutDisplay, 0.05);

class SearchWorkflow
{
	ManipulatorPointer[] pointers;
	Informatics informatics = NULL;
	CuboidCreator cuboid = NULL;
	VolumeContainer[] resultContainer = NULL;
	VolumeID volume = NULL;
	ToolManipulators[] tools = NULL;
	int nbLesions;
	Segment[] resultSegments = NULL;

	SearchWorkflow( ManipulatorPointer[] ps, Informatics i, CuboidCreator c, VolumeContainer[] container, VolumeID v, ToolManipulators[] t, int nbContainers, Segment[] rs  )
	{
		pointers = ps;
		informatics = i;
		cuboid = c;
		resultContainer = container;
		volume = v;
		tools = t;
		nbLesions = nbContainers;
		resultSegments = rs;
	}

	void run()
	{
		Volume v = volume.getVolume();

		Vector3f min = v.positionToIndex( cuboid.cuboid.getP1() );
		Vector3f max = v.positionToIndex( cuboid.cuboid.getP2() );
		if ( min[ 0 ] > max[ 0 ] )
		{
			swap( min[ 0 ], max[ 0 ] );
		}
		if ( min[ 1 ] > max[ 1 ] )
		{
			swap( min[ 1 ], max[ 1 ] );
		}
		if ( min[ 2 ] > max[ 2 ] )
		{
			swap( min[ 2 ], max[ 2 ] );
		}

		Lesion[] lesions = informatics.findClosestLesions( volume, min, max, nbLesions );

		int n = 0;
		while ( n < nbLesions )
		{
			if ( n >= size( lesions ))
			{
				break;
			}
			VolumeID lesionID = lesions[ n ].loadVolume();
			Volume lesion = lesionID.getVolume();
			println( "loaded volume:" );
			print( lesionID );

			Lut lut( 0.0, 1.0 );
			lut.detectRange( lesionID, 0.49 );
			resultContainer[ n ].clear();
			resultContainer[ n ].add( lesionID, lut );

			tools[ n ].clear();
			tools[ n ].add( pointers[ n ] );
			
			Vector3f start = lesion.indexToPosition( lesions[ n ].getMinBoundingBoxIndex() );
			Vector3f end = lesion.indexToPosition( lesions[ n ].getMaxBoundingBoxIndex() );
			Vector3f center( ( start[ 0 ] + end[ 0 ] ) / 2.0,
							 ( start[ 1 ] + end[ 1 ] ) / 2.0,
							 ( start[ 2 ] + end[ 2 ] ) / 2.0 );

			pointers[ n ].setPosition( center );
			//resultSegments[ n * 3 + 0 ].setAxis
			ManipulatorCuboid cuboid( start, end );
			tools[ n ].add( cuboid );
			n = n + 1;
		}
	}

	void clear()
	{
		int n = 0;
		while ( n < nbLesions )
		{
			tools[ n ].clear();
			resultContainer[ n ].clear();
			n = n + 1;
		}
	}
}

CuboidCreator creator( manipultors );
creator.start();


Informatics informatics;
SearchWorkflow search( pointers, informatics, creator, volumesResult, pet, manipulatorsResult, 3, resultSegments );
KeyboardCallback callbacks;
callbacks.addShortcut( search.run, "F1" );
callbacks.addShortcut( search.clear, "F2" );
callbacks.addShortcut( creator.start, "F3" );
