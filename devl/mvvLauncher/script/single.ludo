
import "core"
import "siemens"
import "mvvDicomTools"
include "helper1"

/**
 @brief Store the case attributs
 */
class VolumeFile
{
   // defines the constants for landmarks
   int LANDMARKS_NB;
   int LD_DENS;
   int LD_LUNGL;
   int LD_LUNGR;
   int LD_AORTIC_ARCH;
   int LD_HUMERUSL;
   int LD_HUMERUSR;
   int LD_SBLADEL;
   int LD_SBLADER;
   int LD_HEART_VEIN_CAVE_ENTRANCE;
   int LD_CARINA;
   int LD_PORTAL_VEIN;
   int LD_SPLEEN_HEAD;
   int LD_KIDNEYL;
   int LD_KIDNEYR;
   int LD_HIPS;
   int LD_FEMURL;
   int LD_FEMURR;
   int LD_COCCYX;
   string[] LD_STRINGS;

   // private attributs
   class LandmarkAnnotation
   {
      LandmarkAnnotation(){}

      Vector3f       pos;           // position in INDEX, only used for serialization, else use <ManipulatorPoint> methods
      Vector3f       oldPos;        // position in INDEX
      ManipulatorPoint id = NULL;
   }

   string caseId = "unknown";
   LandmarkAnnotation[] landmarks;     // hold the landmarks found
   ToolManipulators manipulators = NULL;
   ManipulatorPointer pointer = NULL;

   void print()
   {
      int n = 1;
      while ( n <= LANDMARKS_NB )
      {
         println( "feature[" + toString(n) + "]=" + toString( landmarks[ n ].pos[ 0 ] ) + ", "
                                                  + toString( landmarks[ n ].pos[ 1 ] ) + ", "
                                                  + toString( landmarks[ n ].pos[ 2 ] ) + ", " );
         n = n + 1;
      }
      println( "caseId=" + caseId );
   }

   VolumeFile()
   {
      emptyLandmarks();
   }

   void emptyLandmarks()
   {
      //
      // defines the landmarks used
      //
      LANDMARKS_NB = 18;
      LD_DENS                      = 1;
      LD_LUNGR                     = 2;
      LD_LUNGL                     = 3;
      LD_AORTIC_ARCH               = 4;
      LD_HUMERUSR                  = 5;
      LD_HUMERUSL                  = 6;
      LD_SBLADER                   = 7;
      LD_SBLADEL                   = 8;
      LD_HEART_VEIN_CAVE_ENTRANCE  = 9;
      LD_CARINA                    = 10;
      LD_PORTAL_VEIN               = 11;
      LD_SPLEEN_HEAD               = 12;
      LD_KIDNEYR                   = 13;
      LD_KIDNEYL                   = 14;
      LD_HIPS                      = 15;
      LD_FEMURR                    = 16;
      LD_FEMURL                    = 17;
      LD_COCCYX                    = 18;

      string strs[] =
      {
         "EMPTY",
         "Dens' tip",
         "Right Lung's tip",
         "Left Lung's tip",
         "Aortic Arch",
         "Right Humerus tip",
         "Left Humerus tip",
         "Right shoulder blade tip",
         "Left shoulder blade tip",
         "Heart vein cave entrance",
         "Carina",
         "Liver Portal Vein entrance",
         "Spleen Vein entrance",
         "Right Kidney",
         "Left Kidney",
         "Center Hips",
         "Right Femur tip",
         "Left Femur tip",
         "Coccyx"
      };
      LD_STRINGS = strs;

      int sizeBuf = LANDMARKS_NB + 1;
      LandmarkAnnotation ls[ sizeBuf ];
      int n = 0;
      while ( n < sizeBuf )
      {
         LandmarkAnnotation a;
         Vector3f v1( -1.0, -1.0, -1.0 );
         Vector3f v2( -1.0, -1.0, -1.0 );
         a.pos = v1;
         a.oldPos = v2;
         ls[ n ] = a;
         n = n + 1;
      }
      landmarks = ls;
   }


   void write( string file, Volume v )
   {
      
      assert( v != NULL, "EMPTY VOLUME" );
      OFStream f( file );
      f.write( "nbFeatures=" + toString( LANDMARKS_NB ) + "\n" );

      int n = 1;
      while ( n <= LANDMARKS_NB )
      {
         Vector3f pos;
         if ( landmarks[ n ].id != NULL )
         {
            pos = v.positionToIndex( landmarks[ n ].id.getPosition() );
         } else {
            pos = Vector3f( -1.0, -1.0, -1.0 );
         }
         f.write( "id-" + toString( n ) + "=" + toString( pos[ 0 ] ) + ", "
                                              + toString( pos[ 1 ] ) + ", "
                                              + toString( pos[ 2 ] ) + "\n" );
         n = n + 1;
      }
      f.write( "caseId=" + caseId );
   }

   int toInt( string v )
   {
      return round( toFloat( v ) );
   }

   void addLandmark( int id, Vector3f pos )
   {
      if ( landmarks[ id ].id == NULL )
      {
         ManipulatorPoint point( pos, LD_STRINGS[ id ], 16, Vector3i(0, 255, 0), 30.0 );
         manipulators.add( point );
         landmarks[ id ].id = point;
      } else {
         landmarks[ id ].id.setPosition( pos );
      }
   }

   void read( string file, Volume v )
   {
      manipulators.clear();
      manipulators.add( pointer );
      emptyLandmarks();

      IFStream f( file );
      if ( f.good() )
      {
         string line = f.getline();
         string[] parts = split( line, "=" );
         assert( size( parts ) == 2, "must be nbFeatures=XXX format" );
         assert( parts[ 0 ] == "nbFeatures", "must be nbFeatures=XXX format" );
         assert( toInt( parts[ 1 ] ) == LANDMARKS_NB, "it must be exactly LANDMARKS_NB features, else not good version" );

         int n = 1;
         while ( n <= LANDMARKS_NB )
         {
            line = f.getline();
            parts = split( line, "=" );
            assert( size( parts ) == 2, "must be id-XX=XXX format"  );
            string[] parts2 = split( parts[ 0 ], "-" );
            assert( size( parts2 ) == 2, "must be id-XX=XXX format" );
            assert( toInt( parts2[ 1 ] ) == n, "feature ID doesn't match!" );
            string[] parts3 = split( parts[ 1 ], "," );
            assert( size( parts3 ) == 3, "it must be XX, XX, XX format" );
            landmarks[ n ].pos[ 0 ] = toFloat( parts3[ 0 ] );
            landmarks[ n ].pos[ 1 ] = toFloat( parts3[ 1 ] );
            landmarks[ n ].pos[ 2 ] = toFloat( parts3[ 2 ] );

            // display it in MM
            Vector3f pos = v.indexToPosition( landmarks[ n ].pos );
            if ( landmarks[ n ].pos[ 0 ] >= 0.0 &&
                 landmarks[ n ].pos[ 1 ] >= 0.0 &&
                 landmarks[ n ].pos[ 2 ] >= 0.0 )   // if <0, don't display anything
            {
               addLandmark( n, pos );
            }
            n = n + 1;
         }

         line = f.getline();
         parts = split( line, "=" );
         assert( size( parts ) == 2, "must be caseId=XXX format" );
         assert( parts[ 0 ] == "caseId", "must be caseId=XXX format" );
         caseId = parts[ 1 ];
      }
   }
}

class Configuration
{
   // configuration specific
   string dataPath         = "C:/DicomDataRepositery/";                // path where the data is stored
   string index            = "C:/DicomDataRepositery/index/index.txt"; // list of all the cases
   string landmarksOutput  = "C:/DicomDataRepositery/landmarks/";      // where all the landmars are loaded and exported

   // data cache
   int currentCase = -1;               // the current case
   int previousCase = -1;
   int landmarkNavigator = 0;          // the current landmark to sync the MPR

   VolumeID previousCaseId = NULL;    // a pointer on the previous case
   VolumeID currentCaseId = NULL;     // a pointer on the current case
   VolumeID nextCaseId = NULL;        // a pointer on the next case
   VolumeID previousId = NULL;        // the volume displayed the previous time (i.e., independent of the list order)

   ToolManipulators manipulators = NULL;

   // private member variables
   VolumeContainer      volumes;
   Lut                  lut = NULL;
   string[]             volumeList;
   VolumeFile           landmarks;
   ManipulatorPointer   pointer;

   Configuration( VolumeContainer vs, ToolManipulators as, ManipulatorPointer pt )
   {
      lut = Lut( -100.0, 250.0 );
      volumes = vs;
      manipulators = as;
      pointer = pt;

      readCases();
      landmarks.manipulators = manipulators;
      landmarks.pointer = pointer;
   }

   string createStringId( int case )
   {
      string v = volumeList[ case ];
      replace( v, "_", "-" );
      replace( v, "/", "-" );
      replace( v, "\\", "-" );
      return v;
   }

   void addCase( string caseName )
   {
      println( "case=" + caseName );
      int size = size( volumeList );
      int sizen = size + 1;
      string list[ sizen ];

      int n = 0;
      while ( n < size )
      {
         list[ n ] = volumeList[ n ];
         n = n + 1;
      }
      list[ size ] = caseName;
      volumeList = list;
   }

   void readCases()
   {
      IFStream f( index );
      string line = f.getline();
      while ( line != "" )
      {
         addCase( line );
         line = f.getline();
      }
   }

   void nextLandmarkNavigation()
   {
      if ( landmarkNavigator < landmarks.LANDMARKS_NB )
      {
         while (1)
         {
            landmarkNavigator = landmarkNavigator + 1;
            println( "navigateToLandmark=" + toString( landmarkNavigator ) );
            if ( landmarks.landmarks[ landmarkNavigator ].id != NULL )
            {
               pointer.setPosition( landmarks.landmarks[ landmarkNavigator ].id.getPosition() );
               break;
            }
         }
      }
   }

   void previousLandmarkNavigation()
   {
      if ( landmarkNavigator > 1 )
      {
         while (1)
         {
            landmarkNavigator = landmarkNavigator - 1;
            println( "navigateToLandmark=" + toString( landmarkNavigator ) );
            if ( landmarks.landmarks[ landmarkNavigator ].id != NULL )
            {
               pointer.setPosition( landmarks.landmarks[ landmarkNavigator ].id.getPosition() );
               break;
            }
         }
      }
   }

   void next()
   {
      assert( currentCase < size( volumeList ), "no more volume to examine" );
      landmarkNavigator = 0;

      volumes.clear();
      previousCaseId = currentCaseId;
      previousId = currentCaseId;

      previousCase = currentCase;
      currentCase = currentCase + 1;
      if ( nextCaseId != NULL )
      {
         // it is cached!
         currentCaseId = nextCaseId;
         nextCaseId = NULL;
      } else {
         // load it from HD
         string volumePath = dataPath + volumeList[ currentCase ];
         currentCaseId = loadVolume( volumePath );
      }
      saveCase();
      loadCase( currentCase );
      volumes.add( currentCaseId, lut );
   }

   void loadCase( int case )
   {
      string id = createStringId( case );
      println( "loading case landmarks=" + id );

      landmarks.read( landmarksOutput + id + ".txt", getVolume( currentCaseId ) );
      landmarks.caseId = id;
   }

   void saveCase()
   {
      if ( previousCase >= 0 )
      {
         string id = createStringId( previousCase );
         println( "saving case landmarks=" + id );

         landmarks.write( landmarksOutput + id + ".txt", getVolume( previousId )  );
      }
   }

   void previous()
   {
      assert( currentCase > 0 );
      landmarkNavigator = 0;

      volumes.clear();
      nextCaseId = currentCaseId;
      previousId = currentCaseId;

      previousCase = currentCase;
      currentCase = currentCase - 1;
      if ( previousCaseId != NULL )
      {
         currentCaseId = previousCaseId;
         previousCaseId = NULL;
      } else {
         string volumePath = dataPath + volumeList[ currentCase ];
         currentCaseId = loadVolume( volumePath );
      }
      saveCase();
      loadCase( currentCase );
      volumes.add( currentCaseId, lut );
   }

   // load a DICOM directory, or a MF2 file
   VolumeID loadVolume( string v )
   {
      VolumeID id = NULL;
      string[] splits = split( v, "." );
      string extension = splits[ size( splits ) - 1 ];
      if ( extension != "mf2" )
      {
         id = readDicomVolume( v );
      } else {
         id = readVolumeMF2( v );
      }
      return id;
   }

   void addLandmark( int id )
   {
      landmarks.addLandmark( id, pointer.getPosition() );
   }
}

class LandmarkCallbackWrapper
{
   Configuration conf = NULL;
   int landmark = -1;

   LandmarkCallbackWrapper()
   {
   }

   void set( int ld, Configuration c )
   {
      conf = c;
      landmark = ld;
   }

   void add()
   {
      conf.addLandmark( landmark );
   }
}


//
// configuration constants
// -----------------------------------------------------------------------------------------------------------------
//

/// saves the last XXX commands typed by the user, these will be imported next sessions
int      sizeHistoryExport            = 500;

/// defines the export/import location
string   historyExportLocation        = "c:/Temp/command_history.txt";

//
// -----------------------------------------------------------------------------------------------------------------
//

SegmentToolCentering    toolCentering;
MipToolPointer          toolPointerMip(17);
ToolAnnotations         annotations;
ToolManipulators        manipultors;
ManipulatorPointer      pointer;
VolumeContainer         volumes;


//VolumeID ct   = readVolumeMF2Asynchronous("../../nllTest/data/medical/MR-1.mf2");

//Lut ctLut( -50.0, 250.0 );
//DisplayRegionDetection detection( annotations );
//detection.compute( ct );



//AffineRegistration ctReg;
//volumes.add( ct, ctLut, 0.5, ctReg );

manipultors.add( pointer );

Segment segment1( volumes, Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, -1.0, 0.0 ) );
segment1.setTool( toolCentering );
segment1.setTool( manipultors );
segment1.setTool( annotations );

Segment segment2( volumes, Vector3f( 0.0, 1.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment2.setTool( toolCentering );
segment2.setTool( manipultors );
segment2.setTool( annotations );

Segment segment3( volumes, Vector3f( 1.0, 0.0, 0.0 ), Vector3f( 0.0, 0.0, 1.0 ) );
segment3.setTool( toolCentering );
segment3.setTool( manipultors );
segment3.setTool( annotations );

Layout::Vertical vertical;
Layout::Horizontal horizontal;
Layout l1( segment1 );
Layout l2( segment2 );
Layout l3( segment3 );
Layout l6( Console() );

Layout layoutDisplay( vertical, Layout(horizontal, l1, l2, 0.50), l3, 0.50 );
Layout layout = Layout(vertical, l6, layoutDisplay, 0.10);


Configuration conf( volumes, manipultors, pointer );
conf.next();

int nbLandmarks = conf.landmarks.LANDMARKS_NB + 1;
LandmarkCallbackWrapper wrappers[ nbLandmarks ];
int n = 0;
while ( n < nbLandmarks )
{
   wrappers[ n ].set( n, conf );
   n = n + 1;
}




KeyboardCallback callbacks;
callbacks.addShortcut( conf.next, "+" );
callbacks.addShortcut( conf.nextLandmarkNavigation, "+", 2 );
callbacks.addShortcut( conf.previous, "-" );
callbacks.addShortcut( conf.previousLandmarkNavigation, "-", 2 );


callbacks.addShortcut( wrappers[ 1 ].add, "F1" );
callbacks.addShortcut( wrappers[ 2 ].add, "F2" );
callbacks.addShortcut( wrappers[ 3 ].add, "F3" );
callbacks.addShortcut( wrappers[ 4 ].add, "F4" );
callbacks.addShortcut( wrappers[ 5 ].add, "F5" );
callbacks.addShortcut( wrappers[ 6 ].add, "F6" );
callbacks.addShortcut( wrappers[ 7 ].add, "F7" );
callbacks.addShortcut( wrappers[ 8 ].add, "F8" );
callbacks.addShortcut( wrappers[ 9 ].add, "F9" );
callbacks.addShortcut( wrappers[ 10 ].add, "F10" );
callbacks.addShortcut( wrappers[ 11 ].add, "F11" );
callbacks.addShortcut( wrappers[ 12 ].add, "F12" );
callbacks.addShortcut( wrappers[ 13 ].add, "1" );
callbacks.addShortcut( wrappers[ 14 ].add, "2" );
callbacks.addShortcut( wrappers[ 15 ].add, "3" );
callbacks.addShortcut( wrappers[ 16 ].add, "4" );
callbacks.addShortcut( wrappers[ 17 ].add, "5" );
callbacks.addShortcut( wrappers[ 18 ].add, "6" );