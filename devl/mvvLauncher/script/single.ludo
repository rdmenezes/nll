import "core"
import "siemens"
include "helper1"

SegmentToolCentering    toolCentering;
MipToolPointer          toolPointerMip(17);
ToolAnnotations         annotations;
ToolManipulators        manipultors;
ManipulatorPointer      pointer;

VolumeContainer         volumes;
VolumeContainer         volumes2;

manipultors.add( pointer );

Lut petLut( 5000.0, 15000.0, Vector3i( 255, 0, 0 ) );
Lut ctLut( -250.0, 250.0 );

KeyboardCallback callbacks;

// first set
float spacing = 2.0;
Segment segment1( volumes, Vector3f( spacing, 0.0, 0.0 ), Vector3f( 0.0, -spacing, 0.0 ) );
segment1.setTool( manipultors );
segment1.setTool( annotations );

Segment segment2( volumes, Vector3f( 0.0, spacing, 0.0 ), Vector3f( 0.0, 0.0, spacing ) );
segment2.setTool( manipultors );
segment2.setTool( annotations );

Segment segment3( volumes, Vector3f( spacing, 0.0, 0.0 ), Vector3f( 0.0, 0.0, spacing ) );
segment3.setTool( manipultors );
segment3.setTool( annotations );

Layout::Vertical vertical;
Layout::Horizontal horizontal;
Layout l1( segment1 );
Layout l2( segment2 );
Layout l3( segment3 );

// second set
Segment segment4( volumes2, Vector3f( spacing, 0.0, 0.0 ), Vector3f( 0.0, -spacing, 0.0 ) );
segment4.setTool( manipultors );
segment4.setTool( annotations );

Segment segment5( volumes2, Vector3f( 0.0, spacing, 0.0 ), Vector3f( 0.0, 0.0, spacing ) );
segment5.setTool( manipultors );
segment5.setTool( annotations );

Segment segment6( volumes2, Vector3f( spacing, 0.0, 0.0 ), Vector3f( 0.0, 0.0, spacing ) );
segment6.setTool( manipultors );
segment6.setTool( annotations );

Layout l4( segment4 );
Layout l5( segment5 );
Layout l6( segment6 );

Layout layoutDisplay1( vertical, Layout(horizontal, l1, l2, 0.50), l3, 0.50 );
Layout layoutDisplay2( vertical, Layout(horizontal, l4, l5, 0.50), l6, 0.50 );
Layout layout = Layout(horizontal, layoutDisplay1, layoutDisplay2, 0.50);

Segment segments[] =
{
   segment1, segment2, segment3, segment4, segment5, segment6
};

class PostprocessingPrint
{
   string toPrint;

   PostprocessingPrint( string s )
   {
      toPrint = s;
   }

   void run( Image image, Vector2f spacing, Vector3f origin, Vector3f axisx, Vector3f axisy )
   {
      drawText( image,
                toPrint,
                Vector2i( 0, image.sizey() - 26 ),
                25,
                Vector3i( 255, 255, 255 ) );
   }
}

PostprocessingPrint postprocessingAligned( "Default Alignment Only" );
PostprocessingPrint postprocessingTranslation( "Cardiac Registration results" );
segment3.setTool( ToolPostprocessing( postprocessingAligned.run ) );
segment6.setTool( ToolPostprocessing( postprocessingTranslation.run ) );

class Loader
{
   VolumeContainer   volumes1 = NULL;
   VolumeContainer   volumes2 = NULL;
   Lut petLut = NULL;
   Lut ctLut  = NULL;
   int case = 0;
   ManipulatorPointer pointer = NULL;
   Segment[] segments = NULL;

   VolumeID pet = NULL;
   VolumeID ct  = NULL;
   VolumeID ct2 = NULL;

   Loader(VolumeContainer v1, VolumeContainer v2, ManipulatorPointer p, Segment[] ss )
   {
      volumes1 = v1;
      volumes2 = v2;
      pointer = p;
      segments = ss;

      petLut = Lut( 5000.0, 15000.0, Vector3i( 255, 0, 0 ) );
      ctLut = Lut( -250.0, 250.0 );
   }

   void save()
   {
      
      int sx = 1280;
      int sy = 1024;
      Image i( sx, sy, 3 );

      
      copy( i, segments[ 3 ].getImage(), sx / 2, 0 );
      copy( i, segments[ 4 ].getImage(), sx / 2 + sx / 4, 0 );
      copy( i, segments[ 5 ].getImage(), sx / 2, sy / 2 );

      copy( i, segments[ 0 ].getImage(), 0, 0 );
      copy( i, segments[ 1 ].getImage(), sx / 4, 0 );
      copy( i, segments[ 2 ].getImage(), 0, sy / 2 );
      

      writeBmp( i, "c:/tmp/result_case" + toString(case) + ".bmp" );
   }

   void next()
   {
      string baseIn = "N:/MCL/Mirada Test Data Library (MTDL)/CardiacRegistration/v2/";
	   string baseOut = "c:/tmp/";

      volumes1.clear();
      volumes2.clear();

      case = case + 1;
      // handle the missing cases...
      if (case==11)
      {
         case = 12;
      }

      if (case==14)
      {
         case = 15;
      }

      if (case==16)
      {
         case = 17;
      }
      print( "--------case=" + toString(case) + "-----------\n" );

      pet   = readVolumeMF2Asynchronous( baseIn + "NAC" + toString(case) + ".mf2");
      ct    = readVolumeMF2Asynchronous( baseIn + "CT" + toString(case) + ".mf2");
      ct2   = readVolumeMF2Asynchronous("c:/tmp/full-resampledCT-t-Case-" + toString(case) + ".mf2");

      Volume ctVolume = ct.getVolume();
      Volume petVolume = pet.getVolume();

      float diff = -30.0 / petVolume.getSpacing()[ 2 ];
      if ( case > 10 && case < 21)
      {
         petLut = Lut( 0.0, 300.0, Vector3i( 255, 0, 0 ) );
         float diff = -25.0 / petVolume.getSpacing()[ 2 ];
      }
      petLut.detectRange(pet, 0.99);

      volumes1.add( ct, ctLut, 0.3 );
      volumes1.add( pet, petLut, 0.5 );

      volumes2.add( ct2, ctLut, 0.3 );
      volumes2.add( pet, petLut, 0.5 );

      // automatic heart positioning
      RegionDetection detection;
      int[]   rois;
      float[] indexes;

      int[] result = detection.compute( ct, rois, indexes );

      // set the correct position
      assert( result[ 2 ] != -1 );

      Vector3f posSlice( ctVolume.getSize()[ 0 ] / 2.0, ctVolume.getSize()[ 1 ] / 2.0, diff + toFloat( result[ 2 ] ) );
      Vector3f posMM = ctVolume.indexToPosition( posSlice );
      Vector3f posSlicePet = petVolume.positionToIndex( posMM );
      Vector3f sliceMaxIntensity = findMaxVoxel( pet, round( posSlicePet[ 2 ] ) );
      Vector3f maxIntensityMM = petVolume.indexToPosition( sliceMaxIntensity );
      pointer.setPosition( maxIntensityMM );

      save();
   }
}

Loader loader(volumes, volumes2, pointer, segments);

int nbCases = 17;
//while ( nbCases > 0 )
{
   loader.next();
   nbCases = nbCases - 1;
}

callbacks.addShortcut( loader.next, "F3" );