/**
 @ingroup core
 @brief Represent a 3*3 matrix with affine operations defined
 */
class Matrix3f
{
	float vals[ 9 ];

   /**
    @brief Create a 3x3 float matrix
    */
	Matrix3f( float a00 = 1.0, float a01 = 0.0, float a02 = 0.0,
             float a10 = 0.0, float a11 = 1.0, float a12 = 0.0,
             float a20 = 0.0, float a21 = 0.0, float a22 = 1.0 )
	{
		vals[ 0 ] = a00;
		vals[ 1 ] = a01;
		vals[ 2 ] = a02;
		vals[ 3 ] = a10;
		vals[ 4 ] = a11;
		vals[ 5 ] = a12;
		vals[ 6 ] = a20;
		vals[ 7 ] = a21;
		vals[ 8 ] = a22;
	}

   /**
    @brief access the matrix
    */
   float& operator()( int y, int x )
   {
      return vals[ x + y * 3 ];
   }

   /**
    @brief return the size in x
    */
   int sizex()
   {
      return 3;
   }

   /**
    @brief return the size in y
    */
   int sizey()
   {
      return 3;
   }

   Matrix3f operator+( Matrix3f b )
   {
      return Matrix3f( vals[ 0 ] + b.vals[ 0 ], vals[ 1 ] + b.vals[ 1 ], vals[ 2 ] + b.vals[ 2 ],
                       vals[ 3 ] + b.vals[ 3 ], vals[ 4 ] + b.vals[ 4 ], vals[ 5 ] + b.vals[ 5 ],
                       vals[ 6 ] + b.vals[ 6 ], vals[ 7 ] + b.vals[ 7 ], vals[ 8 ] + b.vals[ 8 ] );
   }

   Matrix3f operator-( Matrix3f b )
   {
      return Matrix3f( vals[ 0 ] - b.vals[ 0 ], vals[ 1 ] - b.vals[ 1 ], vals[ 2 ] - b.vals[ 2 ],
                       vals[ 3 ] - b.vals[ 3 ], vals[ 4 ] - b.vals[ 4 ], vals[ 5 ] - b.vals[ 5 ],
                       vals[ 6 ] - b.vals[ 6 ], vals[ 7 ] - b.vals[ 7 ], vals[ 8 ] - b.vals[ 8 ] );
   }

   Matrix3f operator*( float b )
   {
      return Matrix3f( vals[ 0 ] * b, vals[ 1 ] * b, vals[ 2 ] * b,
                       vals[ 3 ] * b, vals[ 4 ] * b, vals[ 5 ] * b,
                       vals[ 6 ] * b, vals[ 7 ] * b, vals[ 8 ] * b );
   }

   Matrix3f operator/( float b )
   {
      assert( b != 0.0, "division by zero!" );
      return Matrix3f( vals[ 0 ] / b, vals[ 1 ] / b, vals[ 2 ] / b,
                       vals[ 3 ] / b, vals[ 4 ] / b, vals[ 5 ] / b,
                       vals[ 6 ] / b, vals[ 7 ] / b, vals[ 8 ] / b );
   }

   float det()
   {
      return vals[ 0 ] * vals[ 4 ] * vals[ 8 ] +
             vals[ 1 ] * vals[ 5 ] * vals[ 6 ] +
             vals[ 2 ] * vals[ 3 ] * vals[ 7 ] -
             vals[ 0 ] * vals[ 5 ] * vals[ 7 ] -
             vals[ 1 ] * vals[ 3 ] * vals[ 8 ] -
             vals[ 2 ] * vals[ 4 ] * vals[ 6 ];
   }
}

/**
 @ingroup core
 @brief Represent a 4*4 matrix with affine operations defined
 */
class Matrix4f
{
	float vals[ 16 ];

   /**
    @brief Create a 3x3 float matrix
    */
	Matrix4f( float a00 = 1.0, float a01 = 0.0, float a02 = 0.0, float a03 = 0.0,
             float a10 = 0.0, float a11 = 1.0, float a12 = 0.0, float a13 = 0.0,
             float a20 = 0.0, float a21 = 0.0, float a22 = 1.0, float a23 = 0.0,
             float a30 = 0.0, float a31 = 0.0, float a32 = 0.0, float a33 = 1.0 )
	{
		vals[ 0 ] = a00;
		vals[ 1 ] = a01;
		vals[ 2 ] = a02;
      vals[ 3 ] = a03;
      
		vals[ 4 ] = a10;
		vals[ 5 ] = a11;
		vals[ 6 ] = a12;
      vals[ 7 ] = a13;
      
		vals[ 8 ]  = a20;
		vals[ 9 ]  = a21;
		vals[ 10 ] = a22;
      vals[ 11 ] = a23;
      
      vals[ 12 ] = a30;
		vals[ 13 ] = a31;
		vals[ 14 ] = a32;
      vals[ 15 ] = a33;
	}

   /**
    @brief return the spacing of the matrix (assumed it is seen as an affine transformation)
    */
   Vector3f getSpacing()
   {
      Vector3f sp( sqrt( sqr( vals[ 0 ] ) + sqr( vals[ 4 ] ) + sqr( vals[ 8 ] ) ),
                   sqrt( sqr( vals[ 1 ] ) + sqr( vals[ 5 ] ) + sqr( vals[ 9 ] ) ),
                   sqrt( sqr( vals[ 2 ] ) + sqr( vals[ 6 ] ) + sqr( vals[ 10 ] ) ) );
      return sp;
   }

   /**
    @brief set the spacing of the matrix (assumed it is seen as an affine transformation)
    */
   void setSpacing( Vector3f sp )
   {
      int n = 0;
      Vector3f spold = this.getSpacing();
      
      vals[ 0 ]  = vals[ 0 ]  / spold[ 0 ] * sp[ 0 ];
      vals[ 4 ]  = vals[ 4 ]  / spold[ 0 ] * sp[ 0 ];
      vals[ 11 ] = vals[ 11 ] / spold[ 0 ] * sp[ 0 ];

      vals[ 1 ]  = vals[ 1 ]  / spold[ 1 ] * sp[ 1 ];
      vals[ 5 ]  = vals[ 5 ]  / spold[ 1 ] * sp[ 1 ];
      vals[ 12 ] = vals[ 12 ] / spold[ 1 ] * sp[ 1 ];

      vals[ 2 ]  = vals[ 2 ]  / spold[ 2 ] * sp[ 2 ];
      vals[ 6 ]  = vals[ 6 ]  / spold[ 2 ] * sp[ 2 ];
      vals[ 13 ] = vals[ 13 ] / spold[ 2 ] * sp[ 2 ];
   }

   /**
    @brief return the rotation of the matrix (assumed it is seen as an affine transformation)
    */
   Matrix3f getRotation()
   {
      Vector3f sp = this.getSpacing();
      Matrix3f r( vals[ 0 ] / sp[ 0 ], vals[ 1 ] / sp[ 1 ], vals[ 2 ] / sp[ 2 ],
                  vals[ 3 ] / sp[ 0 ], vals[ 4 ] / sp[ 1 ], vals[ 5 ] / sp[ 2 ],
                  vals[ 6 ] / sp[ 0 ], vals[ 7 ] / sp[ 1 ], vals[ 8 ] / sp[ 2 ] );
      return r;
   }

   /**
    @brief set the rotation of the matrix (assumed it is seen as an affine transformation)
    */
   void setRotation( Matrix3f r )
   {
      Vector3f sp = this.getSpacing();

      vals[ 0 ]   = r( 0, 0 ) * sp[ 0 ];
      vals[ 4 ]   = r( 1, 0 ) * sp[ 0 ];
      vals[ 11 ]  = r( 2, 0 ) * sp[ 0 ];

      vals[ 1 ]   = r( 0, 1 ) * sp[ 1 ];
      vals[ 5 ]   = r( 1, 1 ) * sp[ 1 ];
      vals[ 12 ]  = r( 2, 1 ) * sp[ 1 ];

      vals[ 2 ]   = r( 0, 2 ) * sp[ 2 ];
      vals[ 6 ]   = r( 1, 2 ) * sp[ 2 ];
      vals[ 13 ]  = r( 2, 2 ) * sp[ 2 ];
   }

   /**
    @brief return translation of the matrix (assumed it is seen as an affine transformation)
    */
   Vector3f getTranslation()
   {
      return Vector3f( vals[ 3 ], vals[ 7 ], vals[ 11 ] ); 
   }

   /**
    @brief set the translation of the matrix (assumed it is seen as an affine transformation)
    */
   void setTranslation( Vector3f t)
   {
      vals[ 3 ]  = t[ 0 ];
      vals[ 7 ]  = t[ 1 ];
      vals[ 11 ] = t[ 2 ];
   }


   /**
    @brief access the matrix
    */
   float& operator()( int y, int x )
   {
      return vals[ x + y * 4 ];
   }

   Matrix4f operator+( Matrix4f b )
   {
      return Matrix4f( vals[ 0 ]  + b.vals[ 0 ],  vals[ 1 ]  + b.vals[ 1 ],  vals[ 2 ]  + b.vals[ 2 ],  vals[ 3 ]  + b.vals[ 3 ],
                       vals[ 4 ]  + b.vals[ 4 ],  vals[ 5 ]  + b.vals[ 5 ],  vals[ 6 ]  + b.vals[ 6 ],  vals[ 7 ]  + b.vals[ 7 ],
                       vals[ 8 ]  + b.vals[ 8 ],  vals[ 9 ]  + b.vals[ 9 ],  vals[ 10 ] + b.vals[ 10 ], vals[ 11 ] + b.vals[ 11 ],
                       vals[ 12 ] + b.vals[ 12 ], vals[ 13 ] + b.vals[ 13 ], vals[ 14 ] + b.vals[ 14 ], vals[ 15 ] + b.vals[ 15 ]);
   }

   Matrix4f operator-( Matrix4f b )
   {
      return Matrix4f( vals[ 0 ]  - b.vals[ 0 ],  vals[ 1 ]  - b.vals[ 1 ],  vals[ 2 ]  - b.vals[ 2 ],  vals[ 3 ]  - b.vals[ 3 ],
                       vals[ 4 ]  - b.vals[ 4 ],  vals[ 5 ]  - b.vals[ 5 ],  vals[ 6 ]  - b.vals[ 6 ],  vals[ 7 ]  - b.vals[ 7 ],
                       vals[ 8 ]  - b.vals[ 8 ],  vals[ 9 ]  - b.vals[ 9 ],  vals[ 10 ] - b.vals[ 10 ], vals[ 11 ] - b.vals[ 11 ],
                       vals[ 12 ] - b.vals[ 12 ], vals[ 13 ] - b.vals[ 13 ], vals[ 14 ] - b.vals[ 14 ], vals[ 15 ] - b.vals[ 15 ]);
   }

   Matrix4f operator*( float b )
   {
      return Matrix4f( vals[ 0 ]  * b, vals[ 1 ]  * b, vals[ 2 ]  * b, vals[ 3 ]  * b,
                       vals[ 4 ]  * b, vals[ 5 ]  * b, vals[ 6 ]  * b, vals[ 7 ]  * b,
                       vals[ 8 ]  * b, vals[ 9 ]  * b, vals[ 10 ] * b, vals[ 11 ] * b,
                       vals[ 12 ] * b, vals[ 13 ] * b, vals[ 14 ] * b, vals[ 15 ] * b );
   }

   Matrix4f operator/( float b )
   {
      assert( b != 0.0, "division by zero!" );
      return Matrix4f( vals[ 0 ]  / b, vals[ 1 ]  / b, vals[ 2 ]  / b, vals[ 3 ]  / b,
                       vals[ 4 ]  / b, vals[ 5 ]  / b, vals[ 6 ]  / b, vals[ 7 ]  / b,
                       vals[ 8 ]  / b, vals[ 9 ]  / b, vals[ 10 ] / b, vals[ 11 ] / b,
                       vals[ 12 ] / b, vals[ 13 ] / b, vals[ 14 ] / b, vals[ 15 ] / b );
   }

   /**
    @brief return the size in x
    */
   int sizex()
   {
      return 4;
   }

   /**
    @brief return the size in y
    */
   int sizey()
   {
      return 4;
   }
}

/**
 @ingroup core
 @brief Create a rotation matrix around the X axis
 @param angle angle in radian
 */
Matrix4f createRotationX( float angle)
{
   return Matrix4f( 1.0, 0.0         , 0.0         , 0.0,
                    0.0, cos( angle ), sin( angle ), 0.0,
                    0.0, -sin( angle), cos( angle ), 0.0,
                    0.0, 0.0         , 0.0         , 1.0 );
}

/**
 @ingroup core
 @brief Create a rotation matrix around the Y axis
 @param angle angle in radian
 */
Matrix4f createRotationY( float angle)
{
   return Matrix4f( cos( angle ), 0.0, sin( angle ), 0.0,
                    0.0         , 1.0, 0.0         , 0.0,
                    -sin( angle), 0.0, cos( angle ), 0.0,
                    0.0         , 0.0, 0.0         , 1.0 );
}

/**
 @ingroup core
 @brief Create a rotation matrix around the Z axis
 @param angle angle in radian
 */
Matrix4f createRotationZ( float angle)
{
   return Matrix4f( cos( angle ), sin( angle ), 0.0, 0.0,
                    -sin( angle), cos( angle ), 0.0, 0.0,
                    0.0         , 0.0         , 1.0, 0.0,
                    0.0         , 0.0         , 0.0, 1.0 );
}

/**
 @ingroup core
 @brief Create a translation matrix around the X axis
 @param angle angle in radian
 */
Matrix4f createTranslation( Vector3f t )
{
   return Matrix4f( 1.0, 0.0, 0.0, t[ 0 ],
                    0.0, 1.0, 0.0, t[ 1 ],
                    0.0, 0.0, 1.0, t[ 2 ],
                    0.0, 0.0, 0.0, 1.0 );
}

/**
 @ingroup core
 @brief general matrix
 */
class Matrixf
{
   import Matrixf( int sy, int sx );

   Matrixf( Matrix3f m )
   {
      Matrixf o( 3, 3 );

      o.set( m( 0, 0 ), 0, 0 );
      o.set( m( 0, 1 ), 0, 1 );
      o.set( m( 0, 2 ), 0, 2 );

      o.set( m( 1, 0 ), 1, 0 );
      o.set( m( 1, 1 ), 1, 1 );
      o.set( m( 1, 2 ), 1, 2 );

      o.set( m( 2, 0 ), 2, 0 );
      o.set( m( 2, 1 ), 2, 1 );
      o.set( m( 2, 2 ), 2, 2 );

      this = o;
   }

   Matrixf( Matrix4f m )
   {
      Matrixf o( 4, 4 );

      o.set( m( 0, 0 ), 0, 0 );
      o.set( m( 0, 1 ), 0, 1 );
      o.set( m( 0, 2 ), 0, 2 );
      o.set( m( 0, 3 ), 0, 3 );

      o.set( m( 1, 0 ), 1, 0 );
      o.set( m( 1, 1 ), 1, 1 );
      o.set( m( 1, 2 ), 1, 2 );
      o.set( m( 1, 3 ), 1, 3 );

      o.set( m( 2, 0 ), 2, 0 );
      o.set( m( 2, 1 ), 2, 1 );
      o.set( m( 2, 2 ), 2, 2 );
      o.set( m( 2, 3 ), 2, 3 );

      o.set( m( 3, 0 ), 3, 0 );
      o.set( m( 3, 1 ), 3, 1 );
      o.set( m( 3, 2 ), 3, 2 );
      o.set( m( 3, 3 ), 3, 3 );

      this = o;
   }

   import ~Matrixf();

   import Matrixf invert();
   import float det();
   import Matrixf operator*( Matrixf m );
   import void set( float val, int y, int x );
   import float get( int y, int x );
}