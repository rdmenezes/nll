/**
 @defgroup mvv

 Principles:
 - volumes are loaded to a central store
 - volume ID hold reference on the actual volumes, if VolumeID is destroyed, then its associated volume too
 - layout holds UI elements, segments & MIP
 - segments && MIP can have tools tailoring their behaviour
 */

/**
 @ingroup mvv
 @brief Represent a volume, can't be instanciated directly! When a VolumeID is destroyed, it's associated volume is unloaded from mvv context and volume's data are not accessible anymore
 */
class VolumeID
{
   /**
    @brief a unique identifier for the volume
    */
   string name;

   /**
    @brief remove the reference of this volume from the mvv context leading eventually to its deallocation
    */
   import ~VolumeID();

   /**
    @brief returns the associated volume
    */   
   Volume getVolume()
   {
      return getVolume( this );
   }
}

/**
 @ingroup mvv
 @brief Affine registration that defines a transformation from source->target space
 @note all volumes are in target space, and all mm positions (i.e. annotations...) are defined in source space
 */
class AffineRegistration
{
   /**
    @brief Create an affine registration
    */
   import AffineRegistration( Matrix4f m = Matrix4f() );
   
   /**
    @brief Release the resources used by this object
    */
   import ~AffineRegistration();
   
   /**
    @brief Update the registration matrix
    */
   import void setMatrix( Matrix4f newMatrix );
   
   /**
    @brief Return the current registration matrix
    */
   import Matrix4f getMatrix();
}

/**
 @ingroup mvv
 @brief Resample a target volume given a new size/orientation and an affine transformation to apply
 */
import VolumeID resampleNearest( VolumeID target, AffineRegistration registration, Vector3i size, Matrix4f pst );

/**
 @ingroup mvv
 @brief Resample a target volume given a new size/orientation
 */
VolumeID resampleNearest( VolumeID target, Vector3i size, Matrix4f pst )
{
   AffineRegistration reg( Matrix4f() );
   return resampleNearest( target, reg, size, pst );
}

/**
 @ingroup mvv
 @brief extract a sub volume centered on a specific point
 @todo bug if rotation in PST target
 */
VolumeID extract( VolumeID target, Vector3f center, Vector3f sizeMM )
{
   // use the same PST matrix except the PST must take into account the BB size
   Volume v = target.getVolume();
   Matrix4f pst = v.getPst();

   Vector3f centerDev( center[ 0 ] - sizeMM[ 0 ] / 2,
                       center[ 1 ] - sizeMM[ 1 ] / 2,
                       center[ 2 ] - sizeMM[ 2 ] / 2 );

   pst.setTranslation( centerDev );

   Vector3i size( round( sizeMM[ 0 ] / v.getSpacing()[ 0 ] ),
                  round( sizeMM[ 1 ] / v.getSpacing()[ 1 ] ),
                  round( sizeMM[ 2 ] / v.getSpacing()[ 2 ] ) );
   return resampleNearest( target, size, pst );
}

/**
 @brief Returns the index of the voxel having the maximum intensity in the entire volume
 */
import Vector3f findMaxVoxel( VolumeID v );

/**
 @brief Returns the index of the voxel having the maximum intensity in the given slice
 */
import Vector3f findMaxVoxel( VolumeID v, int slice );

/**
 @ingroup mvv
 @brief Look up table - assign a color to a voxel value, given a window level
 @note: we can't use operator[] as we need to return a reference, however in memory we don't store a list of Vector3uc
 */
class Lut
{   
   /**
    @brief Replace the color on an index by another one
    @param index an index ranging from 0 to 255
    @param colorR, colorG, colorB a RGB value
    */
   import void setColorIndex( int index, int colorR, int colorG, int colorB );
   
   void setColor( int index, Vector3i color )
   {
      this.setColorIndex( index, color[ 0 ], color[ 1 ], color[ 2 ] );
   }
   
   void setColor( int index,  int colorR, int colorG, int colorB )
   {
      this.setColorIndex( index, colorR, colorG, colorB  );
   }

   /**
    @brief Returns the color mapped to this index
    */
   import Vector3i getColor( int index );

   /**
    @brief transform a real value to a RGB color
    */
   import Vector3i transform( float val );
   
   /**
    @brief Set the range of the LUT linearly
    */
   import void set( float minIntensity, float maxIntensity, Vector3i color = Vector3i( 255, 255, 255 ) );
   
   /**
    @brief Defines the min and max value of the window. Internally, 256 levels will be linearly computed between this min and max.
    @param color the color of the LUT
    */
   import Lut( float minIntensity, float maxIntensity, Vector3i color = Vector3i( 255, 255, 255 ) );
   
   /**
    @brief destroy native resources
    */
   import ~Lut();
}

/**
 @ingroup mvv
 @brief Contains a set of volume with associated display info
 @note it is not storing a VolumeID reference (just a reference on the volume), so if the
       original VolumeID is destroyed, the VolumeContainer will stop displaying the volume
 */
class VolumeContainer
{
   import VolumeContainer();

   /**
    @brief Free the native resources
    */
   import ~VolumeContainer();
   
   /** 
    @brief add a volume with a lut & intensity info
    @param volume the volume to add
    @param lut the lut associated with this volume. the lut object is *not* cloned!
    @param intensity intensity factor - example lets assume we have 3 volumes with intensity 0.5 1 and 0.5, the intensity will be normalized according to their intensity factor
           the actual intensity will be  0.5 / (0.5 + 1 + 0.5) for the first volume
    @note VolumeID may not be actually be loaded
    */
   import void add( VolumeID volume, Lut lut, float intensity = 0.5, AffineRegistration ar = AffineRegistration(Matrix4f()) );
   
   /**
    @brief remove a volume from the container
    @note volume must be stored in this VolumeContainer
    */
   import void erase( VolumeID volume );
   
   /**
    @brief set a new Lut for this VolumeID. This is transmitted by reference (so a modification of the original object will modify the lut)
    @note volume must be stored in this VolumeContainer
    */
   import void setLut( VolumeID volume, Lut newLut );
   
   /**
    @brief set a new intensity for this VolumeID
    @note volume must be stored in this VolumeContainer
    */
   import void setIntensity( VolumeID volume, float newIntensity );

   /**
    @brief Remove all the volumes from the container
    */
   import void clear();
}

/**
 @ingroup mvv
 @brief Hold a volume, this is only valid until its associated VolumeID is alive
 @note internally, the volume contains only one PTR field, holding a reference on the volume. This reference is only valid until it's associated VolumeID is alive.
 @note All volumes are in target space, they can all have a registration matrix which defines their position relative to the source space
 */
class Volume
{
   /**
    @brief return the number of voxels for each dimension
    */
   import Vector3i getSize();
   
   /**
    @brief return the spacing of the volume
    @note that it is not possible to modify the value directly
    */
   import Vector3f getSpacing();

   /**
    @brief set the spacing of the volume
    */
   import void setSpacing( Vector3f spacing );

   /**
    @brief set the spacing of the volume
    @note that it is not possible to modify the value directly
    */
   void setSpacing( float x, float y, float z )
   {
      this.setSpacing(Vector3f(x, y, z ) );
   }
   
   /**
    @brief get the origin of the volume
    */
   import Vector3f getOrigin();
   
   /**
    @brief set the origin of the volume
    @note that it is not possible to modify the value directly
    */
   import void setOrigin( Vector3f origin );

   /**
    @brief set the origin of the volume
    @note that it is not possible to modify the value directly
    */
   void setOrigin( float x, float y, float z )
   {
      this.setOrigin(Vector3f(x, y, z ) );
   }
   
   /**
    @brief get the origin of the volume
    @note that it is not possible to modify the value directly
    */
   import Matrix3f getRotation();
   
   /**
    @brief  set a new rotation (it will be automatically rescaled using the spacing)
    */
   import void setRotation( Matrix3f rotation );
   
   /**
    @brief  set a new Patient Space Transform
    */
   import void setPst( Matrix4f pst );
   
   /**
    @brief return the Patient Scale Transform
    @note that it is not possible to modify the value directly
    */
   import Matrix4f getPst();
   
   /**
    @brief set the intensity of a voxel
    */
   import void setValue( int x, int y, int z, float value );

   /**
    @brief set the intensity of a voxel
    */
   void setValue( Vector3i v, float value )
   {
      this.setValue( v[ 0 ], v[ 1 ], v[ 2 ], value );
   }
   
   /**
    @brief get the intensity of a voxel using trilinear interpolation
    */
   import float getValue( float x, float y, float z );

   /**
    @brief get the intensity of a voxel using trilinear interpolation
    */
   float getValue( Vector3f v )
   {
      return this.getValue( v[ 0 ], v[ 1 ], v[ 2 ] );
   }
   
   /**
    @brief Transform an index position to a target space position
    @note the registration is not taken into account
    */
   import Vector3f indexToPosition( Vector3f index );

   /**
    @brief Transform an target space position to a volume index
    @note the registration is not taken into account
    */
   import Vector3f positionToIndex( Vector3f position );
}

/**
 @ingroup mvv
 @brief computes the barycentre of the LUT transformed volume
 */
import Vector3f barycentre( VolumeID v, Lut l );

/**
 @ingroup mvv
 @brief synchronously load a MF2 volume
 */
import VolumeID readVolumeMF2( string name );

/**
 @ingroup mvv
 @brief asynchronously load a MF2 volume
 */
import VolumeID readVolumeMF2Asynchronous( string name );

/**
 @ingroup mvv
 @brief write a MF2 volume
 */
import void writeVolumeMF2( VolumeID id, string name );

/**
 @ingroup mvv
 @brief write a txt volume
 */
import void writeVolumeTxt( VolumeID id, string name );

/**
 @ingroup mvv
 @brief read a txt volume
 */
import VolumeID readVolumeTxt( string name );

/**
 @ingroup mvv
 @brief write a binary volume
 The header is stored as a text, but the data is exported as a raw binary volume, storing XY slice contiguously
 */
import void writeVolumeBin( VolumeID id, string name );

/**
 @ingroup mvv
 @brief read a binary volume
 The header is stored as a text, but the data is exported as a raw binary volume, storing XY slice contiguously
 */
import VolumeID readVolumeBin( string name );

/**
 @ingroup mvv
 @brief get a volume, if the volume is being loaded, the call is blocked until the volume is fully loaded
 */
import Volume getVolume( VolumeID id );

/**
 @ingroup mvv
 @brief print a volume
 */
void print( Volume v )
{
   print( v.getPst() );
   println( "size:" + toString( v.getSize()[ 0 ] ) + " " + toString( v.getSize()[ 1 ] ) + " " + toString( v.getSize()[ 2 ] ) );
}

/**
 @ingroup mvv
 @brief print a volume
 */
void print( VolumeID v )
{
   print( getVolume( v ) );
}

/**
 @ingroup mvv
 @brief Center segments when new bigger volumes are loaded
 */
class SegmentToolCentering
{
   /**
    @brief Allocate the native resource
    */
   import SegmentToolCentering();

   /**
    @brief Free the native resources
    */
   import ~SegmentToolCentering();
}

/**
 @ingroup mvv
 @brief Tool displaying annotations on segments
 @TODO refactoring of the annotations: internally, each annotation should be a tool and a resource
       so that they can be queried and modified interactively (no global container as of now...)
       in mvv, new classes for each annotations should be created with the proper getter/setter
 */
class ToolAnnotations
{
   /**
    @note not constructible ID. hold an intval
    */
   class AnnotationID
   {}

   /**
    @brief Allocate the native resources
    */
   import ToolAnnotations();

   /**
    @brief Free the native resources
    */
   import ~ToolAnnotations();

   /**
    @brief create a point annotation
    @returns a unique annotation ID
    */
   import AnnotationID add( Vector3f position, string text, Vector3i color = Vector3i( 255, 255, 255 ) );
   
   /**
    @brief create a line annotation, following the direction given
    */
   import AnnotationID add( Vector3f position, Vector3f direction, string text, Vector3i color = Vector3i( 255, 255, 255 ), float size = 450.0 );

   /**
    @brief create rectangle with different colors along the sizeMM
    */
   import AnnotationID add( Vector3f position, Vector3f sizeMM, int widhPixel, Vector3i[] colors );

   /**
    @brief erase the annotation represented by this ID
    */
   import void erase( AnnotationID id );
   
   /**
    @brief erase all annotations
    */
   import void clear();
   
   /**
    @brief Update the position of an annotation and update all connected segments/mips
    */
   import void setPosition( AnnotationID id, Vector3f position );

   /**
    @brief Returns the position of an annotation
    */
   import Vector3f getPosition( AnnotationID id );

   // TODO
   // import string[] toString();
}

/**
 @ingroup mvv
 @brief Defines a callback to postprocess a MPR/MIP
 @param origin coordinate of the bottom left of the segment
 @param axisx the normalized x axis of the segment, norm = 1
 @param axisy the normalized y axis of the segment, norm = 1
 */
typedef void(Image image, Vector2f spacing, Vector3f origin, Vector3f axisx, Vector3f axisy)   PostprocessingCallback;

/**
 @ingroup mvv
 @brief Tool holding a callback to postprocess a slice
 @note object is necessary to hold the internal 'ToolPostProcessingInterface'
 */
class ToolPostprocessing
{
   import ToolPostprocessing( PostprocessingCallback callback );
   import ~ToolPostprocessing();
}

/**
 @ingroup mvv
 @brief Single point that can be manipulated in 3D
 */
class ManipulatorPoint
{
   import ManipulatorPoint( Vector3f positionMM, string txt = "", int txtSize = 12 );
   import ~ManipulatorPoint();

   /**
    @brief return the position of the point
    */
   import Vector3f getPosition();

   /**
    @brief set the position of a point
    @note m is needed to notify() the container holding p (else, it will not be notified on the screen...)
    */
   import void setPosition( Vector3f p );
}

/**
 @ingroup mvv
 @brief Represents a cuboid that can be manipulated
        
        The controls are:  - min/max cuboid points to change the dimension of the cuboid
                           - center to translate the cuboid
 */
class ManipulatorCuboid
{
   import ManipulatorCuboid( Vector3f min, Vector3f max, Vector3i color = Vector3i( 0, 0, 255 ) );
   import ~ManipulatorCuboid();

   import Vector3f getP1();
   import Vector3f getP2();
   import void setP1( Vector3f point );
   import void setP2( Vector3f point );
}

/**
 @ingroup mvv
 @brief Add a pointer to manipulate and synchronize segments
 @note set and get position are available from the ToolManipulators only: setPos need to refresh the segment!
 */
class ManipulatorPointer
{
   import ManipulatorPointer();
   import ~ManipulatorPointer();

   /**
    @brief return the position of the point
    */
   import Vector3f getPosition();

   /**
    @brief set the position of a point
    */
   import void setPosition( Vector3f p );
}

/**
 @ingroup mvv
 @brief Tool holding manipulators (i.e., objects that can be manipulated interactively by the user)
 @note internally if a manipulator is attached, a reference on it is saved
 */
class ToolManipulators
{
   /**
    @brief creates the native resources
    */
   import ToolManipulators();

   /**
    @brief deallocates the native resources
    */
   import ~ToolManipulators();

   /**
    @brief add a single spot that can be positioned in 3D
    */
   import void add( ManipulatorPoint manipulator );
   import void add( ManipulatorPointer manipulator );
   import void add( ManipulatorCuboid manipulator );

   /**
    @brief Removes the maipulator from the list
    */
   import void erase( ManipulatorPoint manipulator );
   import void erase( ManipulatorPointer manipulator );
   import void erase( ManipulatorCuboid manipulator );

   /**
    @brief remove all the manipulators and refresh all linked segments
    */
   import void clear();

   //
   //import string[] toString();
}

/**
 @ingroup mvv
 @brief Represents a MPR segment
 @note reference on tools are saved in the segment
 @note tools attached to a segment can have only one instance (else they will be detached automatically)
 */
class Segment
{
   /**
    @brief Tag for Nearest Neighbour interpolator
    */
   class Nearest{Nearest(){}}

   /**
    @brief Tag for Tri-linear interpolator
    */
   class Linear{Linear(){}}

   /**
    @brief Free the native resources
    */
   import ~Segment();
   
   /**
    @brief Construct a new segment.
    @param container the volumes to display (note the object is not cloned!)
    @param axisx the x-axis of the segment. its norm defines the spacing used
    @param axisy the y-axis of the segment. its norm defines the spacing used
    @param position the inital position of the segment
    */
   import Segment( VolumeContainer container,
                   Vector3f axisx    = Vector3f( 1.0, 0.0, 0.0 ),
                   Vector3f axisy    = Vector3f( 0.0, 1.0, 0.0 ),
                   Vector3f position = Vector3f( 0.0, 0.0, 0.0 ) );

   /**
    @brief Refresh the entire segment
    */
   import void refresh();

   /**
    @brief set a Nearest Neighbour interpolator for this segment
    */
   import void setInterpolator( Nearest i );

   /**
    @brief set a Tri-linear interpolator for this segment
    */
   import void setInterpolator( Linear i );
   
   /**
    @brief attach annotations
    */
   import void setTool( ToolAnnotations annotations );

   /**
    @brief attach centering tool
    */
   import void setTool( SegmentToolCentering centering );

   /**
    @brief callback that will be called after all MPR rendering processing have been done to add an easy (but inefficient)
           postprocessing effect
    */
   import void setTool( ToolPostprocessing callback );

   /**
    @brief set manipulators (i.e., objects that can be interactively manipulated by the user)
    */
   import void setTool( ToolManipulators manipulators );

   /**
    @brief return the image currently displayed by the MPR without any annotations
    @note this will create a new image, and not a reference on the MPR output
    @note blocking call: the thread will wait until the MPR can be fully displayed (e.g., volume is loading/going to be rendered...)
    */
   import Image getRawImage();

   /**
    @brief return the image currently displayed by the MPR with annotations and tools
    @note this will create a new image, and not a reference on the MPR output
    @note blocking call: the thread will wait until the MPR can be fully displayed (e.g., volume is loading/going to be rendered...)
    */
   import Image getImage();
   
   /**
    @brief return the raw data of a MPR of a volume. The segment must be in a layout to return an up to date image.
    @note this will create a new image, and not a reference on the MPR output
    @note blocking call: the thread will wait until the MPR can be fully displayed (e.g., volume is loading/going to be rendered...)
    */
   import Imagef getRawImage( VolumeID v );
}

/**
 @ingroup mvv
 @brief Allows a mip to be manipulated
 */
class MipToolPointer
{
   /**
    @param frameRate the framerate used to rotate the MIP
    */
   import MipToolPointer( int frameRate = 9 );

   /**
    @brief Free the native resources
    */
   import ~MipToolPointer();
}

/**
 @ingroup mvv
 @brief Display a maximum intensity projection volume
 */
class Mip
{
   /**
    @brief volume the volume to display in the MIP
    @param lut the lut used to display the volume
    @param nbFrame the number of frames to be computed by the MIP (the more frame the the fluidest is the movement)
    */
   import Mip( VolumeID volume, Lut lut, int nbFrame = 48 );

   /**
    @brief Free the native resources
    */
   import ~Mip();

   /**
    @brief set a new volume
    */
   import void setVolume( VolumeID v );

   /**
    @brief Attach a pointer to the MIP
    */
   import void setTool( MipToolPointer pointer );

   /**
    @brief Attach annotations to the MIP
    */
   import void setTool( ToolAnnotations annotations );

   /**
    @brief callback that will be called after all MPR rendering processing have been done to add an easy (but inefficient)
           postprocessing effect
    */
   import void setTool( ToolPostprocessing callback );

   /**
    @brief force a redisplay of the MIP
    */
   import void notify();
}

/**
 @ingroup mvv
 @brief Displays a console to enable user/script interaction
 */
class Console
{
   Console(){}
}

/**
 @ingroup mvv
 @brief Define a layout displaying the UI elements, segments & MIPs
 */
class Layout
{
   /**
    @brief Vectival tag
    */
   class Vertical
   {
      Vertical(){}
   }

   /**
    @brief Horizontal tag
    */
   class Horizontal
   {
      Horizontal(){}
   }

   /**
    @brief Free the native resources
    */
   import ~Layout();

   /**
    @brief Create a horizontal split line composed of two other layouts
    */
   import Layout( Vertical   tag, Layout left, Layout right, float ratio );

   /**
    @brief Create a vertical split line composed of two other layouts
    */
   import Layout( Horizontal tag, Layout left, Layout right, float ratio );

   /**
    @brief Create a layout fully filled with a segment
    @note a reference on the segment is saved in the layout
    */
   import Layout( Segment segment );

   /**
    @brief Create a layout fully filled with a mip
    @note a reference on the mip is saved in the layout
    */
   import Layout( Mip mip );


   /**
    @brief Create a layout fully filled with a console
    @note a reference on the console is saved in the layout
    */
   import Layout( Console console );

   /**
    @brief Create a layout fully filled by an image
    @note a reference on the ImageHolder is saved in the layout
    */
   import Layout( ImageHolder imageHolder );
}