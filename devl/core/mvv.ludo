include "core"

/**
 Principles:
 - volumes are loaded to a central store
 - volume ID hold reference on the actual volumes, if VolumeID is destroyed, then its associated volume too
 - layout holds UI elements, segments & MIP
 - segments && MIP can have tools tailoring their behaviour
 */

/**
 @brief Represent a volume, can't be instanciated directly! When a VolumeID is destroyed, it's associated volume is unloaded from mvv context and volume's data are not accessible anymore
 */
class VolumeID
{
   /**
    @brief a unique identifier for the volume
    */
   string name;

   /**
    @brief remove the reference of this volume from the mvv context leading eventually to its deallocation
    */
   import ~VolumeID();

   /**
    @brief returns the associated volume
    */   
   Volume getVolume()
   {
      return getVolume( this );
   }
}

/**
 @brief Affine registration that defines a transformation from source->target space
 @note all volumes are in target space, and all mm positions (i.e. annotations...) are defined in source space
 */
class AffineRegistration
{
   /**
    @brief Create an affine registration
    */
   import AffineRegistration( Matrix4f m = Matrix4f() );
   
   /**
    @brief Release the resources used by this object
    */
   import ~AffineRegistration();
   
   /**
    @brief Update the registration matrix
    */
   import void setMatrix( Matrix4f newMatrix );
   
   /**
    @brief Return the current registration matrix
    */
   import Matrix4f getMatrix();
}
   
/**
 @brief Look up table - assign a color to a voxel value, given a window level
 @note: we can't use operator[] as we need to return a reference, however in memory we don't store a list of Vector3uc
 */
class Lut
{   
   /**
    @brief Replace the color on an index by another one
    @param index an index ranging from 0 to 255
    @param colorR, colorG, colorB a RGB value
    */
   import void setColorIndex( int index, int colorR, int colorG, int colorB );
   
   void setColor( int index, Vector3i color )
   {
      this.setColorIndex( index, color[ 0 ], color[ 1 ], color[ 2 ] );
   }
   
   void setColor( int index,  int colorR, int colorG, int colorB )
   {
      this.setColorIndex( index, colorR, colorG, colorB  );
   }

   /**
    @brief Returns the color mapped to this index
    */
   import Vector3i getColorIndex( int index );

   /**
    @brief transform a real value to a RGB color
    */
   import Vector3i transform( float val );
   
   /**
    @brief Set the range of the LUT linearly
    */
   import void set( float minIntensity, float maxIntensity, Vector3i color = Vector3i( 255, 255, 255 ) );
   
   /**
    @brief Defines the min and max value of the window. Internally, 256 levels will be linearly computed between this min and max.
    @param color the color of the LUT
    */
   import Lut( float minIntensity, float maxIntensity, Vector3i color = Vector3i( 255, 255, 255 ) );
   
   /**
    @brief destroy native resources
    */
   import ~Lut();
}

/**
 @brief Contains a set of volume with associated display info
 @note it is not storing a VolumeID reference (just a reference on the volume), so if the
       original VolumeID is destroyed, the VolumeContainer will stop displaying the volume
 */
class VolumeContainer
{
   //  //PRIVATE DATA for VolumeID//                 //
   //  //PRIVATE DATA for Lut//                      //

   import VolumeContainer();

   /**
    @brief destroy native resources
    */
   import ~VolumeContainer();
   
   /** 
    @brief add a volume with a lut & intensity info
    @param volume the volume to add
    @param lut the lut associated with this volume. the lut object is *not* cloned!
    @param intensity intensity factor - example lets assume we have 3 volumes with intensity 0.5 1 and 0.5, the intensity will be normalized according to their intensity factor
           the actual intensity will be  0.5 / (0.5 + 1 + 0.5) for the first volume
    @note VolumeID may not be actually be loaded
    */
   import void add( VolumeID volume, Lut lut, float intensity = 0.5, AffineRegistration ar = AffineRegistration(Matrix4f()) );
   
   /**
    @brief remove a volume from the container
    @note volume must be stored in this VolumeContainer
    */
   import void erase( VolumeID volume );
   
   /**
    @brief set a new Lut for this VolumeID. This is transmitted by reference (so a modification of the original object will modify the lut)
    @note volume must be stored in this VolumeContainer
    */
   import void setLut( VolumeID volume, Lut newLut );
   
   /**
    @brief set a new intensity for this VolumeID
    @note volume must be stored in this VolumeContainer
    */
   import void setIntensity( VolumeID volume, float newIntensity );
}

/**
 @brief Hold a volume, this is only valid until its associated VolumeID is alive
 @note internally, the volume contains only one PTR field, holding a reference on the volume. This reference is only valid until it's associated VolumeID is alive.
 @note All volumes are in target space, they can all have a registration matrix which defines their position relative to the source space
 */
class Volume
{
   // return the number of voxels for each dimension
   import Vector3i getSize();
   
   // note that it is not possible to modify the value directly
   import Vector3f getSpacing();
   import void setSpacing( Vector3f spacing );
   void setSpacing( float x, float y, float z )
   {
      this.setSpacing(Vector3f(x, y, z ) );
   }
   
   // note that it is not possible to modify the value directly
   import Vector3f getOrigin();
   
   // set a new origin
   import void setOrigin( Vector3f origin );
   void setOrigin( float x, float y, float z )
   {
      this.setOrigin(Vector3f(x, y, z ) );
   }
   
   // note that it is not possible to modify the value directly
   import Matrix3f getRotation();
   
   // set a new rotation (it will be automatically rescaled using the spacing)
   import void setRotation( Matrix3f rotation );
   
   // set a new Patient Space Transform
   import void setPst( Matrix4f pst );
   
   // note that it is not possible to modify the value directly
   import Matrix4f getPst();
   
   // the intensity of a voxel
   import void setValue( int x, int y, int z, float value );
   void setValue( Vector3i v, float value )
   {
      this.setValue( v[ 0 ], v[ 1 ], v[ 2 ], value );
   }
   
   // get a voxel value using bilinear interpolation
   import float getValue( float x, float y, float z );
   float getValue( Vector3f v )
   {
      return this.getValue( v[ 0 ], v[ 1 ], v[ 2 ] );
   }
   
   import Vector3f indexToPosition( Vector3f index );
   import Vector3f positionToIndex( Vector3f position );
}

// synchronously load the volume
import VolumeID loadVolumeMF2( string name );

// asynchronously load a volume
import VolumeID loadVolumeAsynchronous( string name );

// get a volume, if the volume is being loaded, the call is blocked until the volume is fully loaded
import Volume getVolume( VolumeID id );

void print( Volume v )
{
   print( v.getPst() );
   println( "size:" + toString( v.getSize()[ 0 ] ) + " " + toString( v.getSize()[ 1 ] ) + " " + toString( v.getSize()[ 2 ] ) );
}

void print( VolumeID v )
{
   print( getVolume( v ) );
}

/**
 @brief Center segments when new bigger volumes are loaded
 */
class SegmentToolCentering
{
   import SegmentToolCentering();
   import ~SegmentToolCentering();
}

/**
 @brief Synchronize all the linked segments on a unique position
 */
class SegmentToolPointer
{
   /**
    @param fontSize the size to be used to display position information
    */
   import SegmentToolPointer( int fontSize = 12 );
   import ~SegmentToolPointer();

   /**
    @brief Set the position of the camera
    */
   //import void setPosition( float x, float y, float z );
   //import void setPosition( Vector3f position );

   /**
    @brief Returns the position of the camera
    */
   import Vector3f getPosition();
}

/**
 @brief Tool displaying annotations on segments
 */
class ToolAnnotations
{
   // not constructible ID. hold an intval
   class AnnotationID
   {}

   import ToolAnnotations();
   import ~ToolAnnotations();

   /**
    @brief create an annotation
    @returns a unique annotation ID
    */
   import AnnotationID add( Vector3f position, string text, Vector3i color = Vector3i( 255, 255, 255 ) );

   /**
    @brief erase the annotation represented by this ID
    */
   import void erase( AnnotationID id );
   
   /**
    @brief erase all annotations
    */
   import void clear();
   
   import void setPosition( AnnotationID id, Vector3f position );
   import Vector3f getPosition( AnnotationID id );
}

/**
 @brief Tool allowing a segment to be manipulated (zmoved/zoomed/panned)
 @note all the segments must be orthogonal
 */
class SegmentToolCamera
{
   import SegmentToolCamera();
   import ~SegmentToolCamera();
   import void setPosition( Vector3f position );
   void setPosition( float x, float y, float z )
   {
      this.setPosition( Vector3f( x, y, z ) );
   }
}

/**
 @brief Represents a MPR segment
 @note reference on tools are saved in the segment
 */
class Segment
{
   class Nearest{Nearest(){}}
   class Linear{Linear(){}}
   
   //  //PRIVATE DATA for segment//                   //
   //  //PRIVATE DATA for VolumeContainer//           //
   //  //PRIVATE DATA for SegmentToolPointer//        //
   //  //PRIVATE DATA for SegmentToolCamera//         //
   //  //PRIVATE DATA for SegmentToolAnnotations//    //
   //  //PRIVATE DATA for SegmentToolCentering//      //

   import ~Segment();
   
   /**
    @brief Construct a new segment.
    @param container the volumes to display (note the object is not cloned!)
    @param axisx the x-axis of the segment. its norm defines the spacing used
    @param axisy the y-axis of the segment. its norm defines the spacing used
    @param position the inital position of the segment
    */
   import Segment( VolumeContainer container,
                   Vector3f axisx    = Vector3f( 1.0, 0.0, 0.0 ),
                   Vector3f axisy    = Vector3f( 0.0, 1.0, 0.0 ),
                   Vector3f position = Vector3f( 0.0, 0.0, 0.0 ) );

   /**
    @brief Refresh the entire segment
    */
   import void refresh();
   import void setInterpolator( Nearest i );
   import void setInterpolator( Linear i );
   
   /**
    @brief attach a pointer: segments will be synchronized & crosshair displayed
    */
   import void setTool( SegmentToolPointer pointer );
   
   /**
    @brief attach a camera: segments can be manipulated
    */
   import void setTool( SegmentToolCamera camera );
   
   /**
    @brief attach annotations
    */
   import void setTool( ToolAnnotations annotations );

   /**
    @brief attach centering tool
    */
   import void setTool( SegmentToolCentering centering );
}

/**
 @brief Allows a mip to be manipulated
 */
class MipToolPointer
{
   import MipToolPointer( int frameRate = 9 );
   import ~MipToolPointer();
}

/**
 @brief Display a maximum intensity projection volume
 */
class Mip
{
   import Mip( VolumeID volume, Lut lut, int nbFrame = 48 );
   import ~Mip();
   import void setTool( MipToolPointer pointer );
   import void setTool( ToolAnnotations annotations );
}

/**
 @brief Displays a console to enable user/script interaction
 */
class Console
{
   Console(){}
}

/**
 @brief Define a layout displaying the UI elements, segments & MIPs
 */
class Layout
{
   // TAG
   class Vertical
   {
      Vertical(){}
   }

   // TAG
   class Horizontal
   {
      Horizontal(){}
   }
   //  //PRIVATE DATA for Layout//                   //
   //  //PRIVATE DATA for segment/MIP//              //
   //  //PRIVATE DATA for left//                     //
   //  //PRIVATE DATA for right//                    //

   import ~Layout();

   import Layout( Vertical   tag, Layout left, Layout right, float ratio );
   import Layout( Horizontal tag, Layout left, Layout right, float ratio );
   import Layout( Segment segment );   // a reference on the segment is saved in the layout
   import Layout( Mip mip );
   import Layout( Console console );
}