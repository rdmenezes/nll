/*
 * Numerical learning library
 * http://nll.googlecode.com/
 *
 * Copyright (c) 2009-2012, Ludovic Sibille
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ludovic Sibille nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY LUDOVIC SIBILLE ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
#ifndef NLL_ALGORITHM_HISTOGRAM_FITTING_H_
# define NLL_ALGORITHM_HISTOGRAM_FITTING_H_

namespace nll
{
namespace algorithm
{
   /**
    @brief Helper to fit gaussian functions on a histogram, assumed the original data being unavailable
    */
   class HistogramFitGaussian
   {
   public:
      /**
       @brief Generate gaussian data from this histogram. Baiscally, if the data were binned, we should find
              an histogram similar to the one given as input
       @param outData a vector<value, histogram index> is generated
       @param noise the gaussian noise added to the data
       */
      template <class Histogram>
      void generateData( const Histogram& h, std::vector< std::vector<double> >& outData, size_t nbPoints = 2000, double noise = 0.1, double* scaleOut = 0 )
      {
         // compute the probability that a particular bin generates a point
         std::vector<double> pb( h.size() );
         double sum = 0;
         double max = std::numeric_limits<double>::min();
         for ( size_t n = 0; n < static_cast<size_t>( h.size() ); ++n )
         {
            sum += h[ n ];
            if ( h[ n ] > max )
            {
               max = (double)h[ n ];
            }
         }

         // the two dimensions can be so different that we need to normalize it so that the histogram size and content
         // can be compared with minimal bias...
         const double scale = 0.1 * static_cast<double>( h.size() ) / max;
         for ( size_t n = 0; n < static_cast<size_t>( h.size() ); ++n )
         {
            pb[ n ] = h[ n ] / sum;
         }

         if ( scaleOut )
         {
            *scaleOut = scale;
         }

         // generate the points
         outData.reserve( nbPoints );
         core::Buffer1D<size_t> sampling = core::sampling( pb, nbPoints );
         for ( size_t n = 0; n < nbPoints; ++n )
         {
            const size_t index = sampling[ n ];
            const double mean = scale * h[ index ];
            const double x = core::generateGaussianDistribution( mean, noise * mean );
            const double y = index + core::generateGaussianDistribution( 0, 0.5 );

            outData.push_back( core::make_vector<double>( x, y ) );
         }
      }

      /**
       @brief Fits the histogram using a mixture of gaussians, returns the likelyhood that the
              given histogram has been generated by the fitted gaussians
       */
      template <class Histogram>
      double fit( const Histogram& h, size_t nbGaussians, size_t nbIter = 0, size_t nbPoints = 1000, double noise = 0.01 )
      {
         double scale;
         std::vector< std::vector<double> > points;
         generateData( h, points, nbPoints, noise, &scale );
         
         Gmm gmm;
         gmm.em( points, 2, nbGaussians, nbIter, 1e-3 );

         _gaussians.clear();
         ensure( gmm.getGaussians().size() == nbGaussians, "wrong number of gaussians, something went wrong!" );
         for ( size_t n = 0; n < nbGaussians; ++n )
         {
            Gmm::Gaussian g = gmm.getGaussians()[ n ];
            g.mean[ 0 ] /= scale;
            _gaussians.push_back( g );
         }

         return gmm.likelihood( points );
      }

      /**
       @brief Returns the computed gaussians. Note that we are using two variables:
              [ 0 ] : the histogram count
              [ 1 ] : the position in the histogram
       */
      const std::vector<Gmm::Gaussian>& getGaussians() const
      {
         return _gaussians;
      }

   private:
      std::vector<Gmm::Gaussian>  _gaussians;
   };
}
}

#endif